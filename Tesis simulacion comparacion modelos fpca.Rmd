---
title: "Simulacion comparacion modelos pca"
author: "santiago eliges"
date: "2025-11-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
source("FQLGR.R")

```

#Comparciòn modelos FPCA
Acá comparo a los modelos basados en componentes principales (Upsilon 0 y 1) cambiando el tamaño de nbasis con misma var treshold (esto podría ser engañoso... Quizá es una comparación injusta comparar con mismo var_treshold en vez de comprar con el mejor para cada uno, pero tambien es interesante comprar como cambian con la misma información explicada. Con esto quiero decir que si en un modelo se consiguen mejores resultados con menos componentes, es posible que sea por que las componentes tienen mucho más ruido y estaria bueno que eso quede también registrado)

```{r}
# =====================================================================
# Funciones Auxiliares para Simulación y Predicción
# =====================================================================


# Funciones auxiliares ---------------------------------------------------

# Regla del trapecio 1D (para vectores x,y)
trapz1d <- function(x, y) {
  if (length(x) != length(y)) stop("x e y deben tener la misma longitud")
  idx <- 2:length(x)
  sum((x[idx] - x[idx - 1]) * (y[idx] + y[idx - 1])) / 2
}

# Integración doble por trapecio (asume matriz Z with rows correspond to s, cols to t)
trapz2d <- function(s, t, Z) {
  if (!all(dim(Z) == c(length(s), length(t)))) {
    stop("Dimensiones de Z deben ser length(s) x length(t)")
  }
  # Integramos respecto a t en cada fila -> vector de longitud length(s)
  int_t_by_row <- apply(Z, 1, function(row) trapz1d(t, row))
  # Integramos el resultado respecto a s
  trapz1d(s, int_t_by_row)
}

# IMSEB univariado -------------------------------------------------------

# beta_true / beta_hat pueden ser:
#  - vectores evaluados en la grilla t
#  - objetos 'fd' de package fda (en cuyo caso se evalúan en una grilla fina)
IMSEB_integral <- function(beta_true, beta_hat, t = NULL, grid_n = 201) {
  # Si son objetos fd, evaluarlos en grilla
  if (inherits(beta_true, "fd") || inherits(beta_hat, "fd")) {
    if (!requireNamespace("fda", quietly = TRUE)) {
      stop("Para pasar objetos 'fd' necesitas instalar paquete 'fda'")
    }
    if (is.null(t)) {
      rng <- beta_true$basis$rangeval
      t <- seq(rng[1], rng[2], length.out = grid_n)
    }
    y_true <- as.numeric(fda::eval.fd(t, beta_true))
    y_hat  <- as.numeric(fda::eval.fd(t, beta_hat))
  } else {
    # beta_true/hat deben ser vectores y se requiere t
    if (is.null(t)) stop("Si pasás vectores debes pasar el vector 't' con la grilla")
    y_true <- as.numeric(beta_true)
    y_hat  <- as.numeric(beta_hat)
    if (length(y_true) != length(t) || length(y_hat) != length(t)) {
      stop("Dimensiones de beta_true/beta_hat deben coincidir con length(t)")
    }
  }
  
  diff2 <- (y_true - y_hat)^2
  integral <- trapz1d(t, diff2)
  T_len <- max(t) - min(t)
  return(as.numeric(integral / T_len))
}

# IMBSEB bivariado -------------------------------------------------------

# Modo A: entradas discretizadas (matrices Z_true, Z_hat) sobre grilla s,t
IMBSEB_integral_grid <- function(Z_true, Z_hat, s, t) {
  if (!all(dim(Z_true) == dim(Z_hat))) stop("Z_true y Z_hat deben tener mismas dimensiones")
  if (!all(dim(Z_true) == c(length(s), length(t)))) stop("Dimensiones de Z_true deben ser length(s) x length(t)")
  
  diff2 <- (Z_true - Z_hat)^2
  integral_xy <- trapz2d(s, t, diff2)
  area <- (max(s) - min(s)) * (max(t) - min(t))
  return(as.numeric(integral_xy / area))
}

# Modo B: entradas en coeficientes de base (A_true, A_hat) y matrices Gram Psi_s, Psi_t
IMBSEB_coef_Kron <- function(A_true, A_hat, Psi_s, Psi_t, s_range = c(0,1), t_range = c(0,1)) {
  # A_true, A_hat : Ks x Kt matrices de coeficientes
  if (!all(dim(A_true) == dim(A_hat))) stop("A_true y A_hat deben tener mismas dimensiones")
  Ks <- nrow(A_true); Kt <- ncol(A_true)
  if (!all(dim(Psi_s) == c(Ks, Ks))) stop("Psi_s debe ser Ks x Ks")
  if (!all(dim(Psi_t) == c(Kt, Kt))) stop("Psi_t debe ser Kt x Kt")
  
  d <- as.vector(A_true - A_hat) # vectorización (col-major por defecto en R)
  Kmat <- kronecker(Psi_t, Psi_s) # (Ks*Kt) x (Ks*Kt)
  area <- (s_range[2] - s_range[1]) * (t_range[2] - t_range[1])
  val <- as.numeric(t(d) %*% Kmat %*% d) / area
  return(val)
}

# Función wrapper que intenta elegir modo apropiado
IMBSEB <- function(gamma_true, gamma_hat, s = NULL, t = NULL, 
                   A_mode = FALSE, Psi_s = NULL, Psi_t = NULL, s_range = NULL, t_range = NULL) {
  # Si A_mode = TRUE se usan coeficientes A_true/A_hat y Psi matrices
  if (A_mode) {
    if (is.null(Psi_s) || is.null(Psi_t)) stop("En modo coeficientes necesitás Psi_s y Psi_t")
    if (is.null(s_range) || is.null(t_range)) stop("s_range y t_range necesarios en modo coeficientes")
    return(IMBSEB_coef_Kron(gamma_true, gamma_hat, Psi_s, Psi_t, s_range, t_range))
  } else {
    # gamma_true/hat deben ser matrices en grilla y s,t provistos
    if (is.null(s) || is.null(t)) stop("Debés pasar s y t (grillas) para el modo grid")
    return(IMBSEB_integral_grid(gamma_true, gamma_hat, s, t))
  }
}

# MSEB -------------------------------------------------------
# Calcula el MSEB definido como:
# (1/(p+1))*[(alpha - alpha_hat)^2 + sum_j (beta_j - beta_hat_j)^2] +
# (1/p^2)*sum_{k,l} (gamma_{k,l} - gamma_hat_{k,l})^2
MSEB <- function(alpha_true, alpha_hat,
                 beta_true, beta_hat,
                 gamma_true, gamma_hat) {
  
  # --- Comprobaciones básicas ---
  if (!is.numeric(alpha_true) || !is.numeric(alpha_hat))
    stop("alpha_true y alpha_hat deben ser escalares numéricos")
  
  if (length(beta_true) != length(beta_hat))
    stop("beta_true y beta_hat deben tener la misma longitud")
  
  if (!all(dim(gamma_true) == dim(gamma_hat)))
    stop("gamma_true y gamma_hat deben tener las mismas dimensiones")
  
  p <- length(beta_true)  # número de covariables funcionales
  
  # --- Cálculo de componentes ---
  term_alpha <- (alpha_true - alpha_hat)^2
  
  term_beta <- sum((beta_true - beta_hat)^2)
  
  term_gamma <- sum((gamma_true - gamma_hat)^2)
  
  # --- MSEB total ---
  mse_b <- (1 / (p + 1)) * (term_alpha + term_beta) +
    (1 / (p^2))   * term_gamma
  
  return(as.numeric(mse_b))
}


predict_log_func <- function(fd_centered, psi, coef_beta, coef_gamma, alpha) {
  n <- dim(fd_centered$coefs)[2]
  probs <- numeric(n)
  for (i in 1:n) {
    lin_part <- fd_centered$coefs[,i] %*% psi %*% coef_beta
    quad_part <- fd_centered$coefs[,i] %*% psi %*% coef_gamma %*% psi %*% fd_centered$coefs[,i]
    modelo_lineal <- alpha + lin_part + quad_part
    probs[i] <- 1 / (1 + exp(-modelo_lineal))
  }
  return(probs)
}

pred_mod_log_func <- function(prob_true) {
  rbinom(length(prob_true), size = 1, prob = prob_true)
}

balance_alpha <- function(fd_centered, psi, coef_beta, coef_gamma, target = 0.5) {
  f <- function(alpha) {
    probs <- predict_log_func(fd_centered, psi, coef_beta, coef_gamma, alpha)
    mean(probs) - target
  }
  uniroot(f, c(-1e5, 1e5))$root
}
```


```{r}
simular_datos_funcionales <- function(t, n = 3000, nbasis = 50, seed = 123,
                                      tipo_basis = "bspline",
                                      escenario = c("ligero", "denso")) {
  library(fda)
  library(MASS)
  
  escenario <- match.arg(escenario)
  set.seed(seed)
  rangeval <- range(t)

  # ================================
  # 1. Selección de base por parámetro
  # ================================
  if (tipo_basis == "bspline") {
    
    if (escenario == "ligero") {
      # ------------------------------
      # ESCENARIO LIGERO:
      # = mantener fijo el número de nudos
      # = aumentar norder según nbasis
      # ------------------------------

      # Definición del orden para respetar nbasis:
      # nbasis = length(knots) + norder - 2
      norder <- min(nbasis - length(knots) + 2, 10)
      if (norder < 2) stop("norder quedó < 2, aumentar num_knots o nbasis.")

      basis <- create.bspline.basis(
        rangeval = rangeval,
        norder = norder,
        nbasis = nbasis
      )

    } else if (escenario == "denso") {
      # ------------------------------
      # ESCENARIO DENSO:
      # = mantener norder fijo
      # = aumentar cantidad de nudos según nbasis
      # ------------------------------
      norder <- 4  # spline cúbico fijo
      num_knots <- nbasis - norder + 2
      knots <- seq(rangeval[1], rangeval[2], length.out = num_knots)

      basis <- create.bspline.basis(
        rangeval = rangeval,
        norder = norder,
        breaks = knots,
        nbasis = nbasis
      )
    }
    
  } else if (tipo_basis == "fourier") {
    
    basis <- create.fourier.basis(
      rangeval = rangeval,
      nbasis = nbasis
    )
    
  } else {
    stop("tipo_basis debe ser 'bspline' o 'fourier'")
  }
  

  
  # ================================
  # 2. Coeficientes correlacionados (AR(1))
  # ================================
  mean_coef <- rnorm(nbasis, sd = seq(1, nbasis) / nbasis)
  rho <- 0.8
  Sigma <- outer(1:nbasis, 1:nbasis, function(i, j) rho^abs(i - j))
  Sigma <- Sigma * diag(seq(nbasis, 1))
  
  coef <- mvrnorm(n, mu = mean_coef, Sigma = Sigma)
  fd_obj <- fd(coef = t(coef), basisobj = basis)
  
  # ================================
  # 3. Verdaderos coeficientes β(t) y γ(s,t)
  # ================================
  s <- t
  
  beta <- 2 * sin(2 * pi * t) + 0.5 * cos(4 * pi * t)
  matriz_beta <- beta / max(abs(beta))
  
  Sigma_gamma <- 0.6
  matriz_gamma <- outer(s, t, function(s, t) {
    exp(-((s - t)^2) / (2 * Sigma_gamma^2)) + 
      0.5 * sin(pi * s) * sin(pi * t)
  })
  matriz_gamma <- (matriz_gamma + t(matriz_gamma)) / 2
  
  # ================================
  # 4. Proyección sobre la base elegida
  # ================================
  fd_beta <- Data2fd(argvals = t, y = matriz_beta, basisobj = basis)
  coef_beta <- fd_beta$coefs
  
  Phi_s <- eval.basis(s, basis)
  Phi_t <- eval.basis(t, basis)
  
  A <- t(Phi_s) %*% matriz_gamma %*% Phi_t
  G_s <- t(Phi_s) %*% Phi_s
  G_t <- t(Phi_t) %*% Phi_t
  
  # Resolver (regularizado si fuera necesario)
  A_est <- solve(G_s) %*% A %*% solve(G_t)
  coef_gamma <- (A_est + t(A_est)) / 2
  
  gamma_recon <- Phi_s %*% A_est %*% t(Phi_t)
  
  # ================================
  # 5. División Train/Valid
  # ================================
  psi <- inprod(basis, basis)
  
  idx_train <- sample(1:n, size = floor(0.7 * n))
  idx_valid <- setdiff(1:n, idx_train)
  
  fd_train <- fd(fd_obj$coefs[, idx_train], basis)
  fd_train <- center.fd(fd_train)
  center_fd_train <- mean.fd(fd_train)
  
  fd_valid <- fd(fd_obj$coefs[, idx_valid], basis)
  fd_valid$coefs <- fd_valid$coefs - as.vector(center_fd_train$coefs)
  
  # ================================
  # 5. Generación de etiquetas
  # ================================
  alpha_true <- balance_alpha(center.fd(fd_obj), psi, coef_beta, coef_gamma)
  
  prob_total <- predict_log_func(center.fd(fd_obj), psi, coef_beta, coef_gamma, alpha_true)
  y_total <- pred_mod_log_func(prob_total)
  
  y_train <- y_total[idx_train]
  y_valid <- y_total[idx_valid]
  
  # ================================
  # 6. Salida
  # ================================
  return(list(
    t = t,
    s = s,
    basis = basis,
    tipo_basis = tipo_basis,
    fd_obj = fd_obj,
    coef = coef,
    alpha = alpha_true,
    coef_beta = coef_beta,
    coef_gamma = coef_gamma,
    beta = beta,
    matriz_beta = matriz_beta,
    matriz_gamma = matriz_gamma,
    gamma_recon = gamma_recon,
    idx_train = idx_train,
    idx_valid = idx_valid,
    fd_train = fd_train,
    y_train = y_train,
    fd_valid = fd_valid,
    y_valid = y_valid,
    psi = psi
  ))
}

```

```{r}
simular_datos_funcionales_chol <- function(
    t, n = 3000, nbasis = 50, seed = 123,
    tipo_basis = "bspline",
    escenario = c("ligero", "denso")) 
{
  library(fda)
  library(MASS)
  
  escenario <- match.arg(escenario)
  set.seed(seed)
  rangeval <- range(t)

  # ================================
  # 1. Selección de base
  # ================================
  if (tipo_basis == "bspline") {
    norder <- 4
    if (escenario == "ligero") {
      knots <- seq(rangeval[1], rangeval[2], length.out = nbasis - norder + 2)
      basis <- create.bspline.basis(rangeval, nbasis = nbasis, norder = norder, breaks = knots)
    } else {
      num_knots <- nbasis - norder + 2
      knots <- seq(rangeval[1], rangeval[2], length.out = num_knots)
      basis <- create.bspline.basis(rangeval, norder = norder, breaks = knots, nbasis = nbasis)
    }
  } else if (tipo_basis == "fourier") {
    basis <- create.fourier.basis(rangeval, nbasis = nbasis)
  } else {
    stop("tipo_basis debe ser 'bspline' o 'fourier'")
  }

  # ================================
  # 2. Coeficientes correlacionados (AR(1))
  # ================================
  mean_coef <- rnorm(nbasis, sd = seq(1, nbasis) / nbasis)
  rho <- 0.8
  Sigma <- outer(1:nbasis, 1:nbasis, function(i, j) rho^abs(i - j))
  Sigma <- Sigma * diag(seq(nbasis, 1))
  coef <- mvrnorm(n, mu = mean_coef, Sigma = Sigma)
  fd_obj <- fd(coef = t(coef), basisobj = basis)

  # ================================
  # ORTONORMALIZACIÓN VIA CHOLESKY
  # ================================
  Psi <- inprod(basis, basis)
  M <- chol(Psi)
  Minv <- solve(M)

  coef_ortho <- Minv %*% fd_obj$coefs
  fd_obj_ortho <- fd(coef = coef_ortho, basisobj = basis)

  # ================================
  # 3. Verdaderos coeficientes β(t) y γ(s,t)
  # ================================
  s <- t
  beta <- 2 * sin(2 * pi * t) + 0.5 * cos(4 * pi * t)
  matriz_beta <- beta / max(abs(beta))

  Sigma_gamma <- 0.6
  matriz_gamma <- outer(s, t, function(s, t) {
    exp(-( (s - t)^2 ) / (2 * Sigma_gamma^2)) +
      0.5 * sin(pi * s) * sin(pi * t)
  })
  matriz_gamma <- (matriz_gamma + t(matriz_gamma)) / 2

  # ================================
  # 4. Proyección sobre la base
  # ================================
  fd_beta <- Data2fd(argvals = t, y = matriz_beta, basisobj = basis)
  coef_beta <- fd_beta$coefs
  coef_beta_ortho <- Minv %*% coef_beta

  Phi_s <- eval.basis(s, basis)
  Phi_t <- eval.basis(t, basis)

  A <- t(Phi_s) %*% matriz_gamma %*% Phi_t
  G_s <- t(Phi_s) %*% Phi_s
  G_t <- t(Phi_t) %*% Phi_t
  A_est <- solve(G_s) %*% A %*% solve(G_t)
  coef_gamma <- (A_est + t(A_est)) / 2
  coef_gamma_ortho <- Minv %*% coef_gamma %*% t(Minv)

  # ================================
  # 4b. Normalizar beta y gamma para no saturar la función logística
  # ================================
  coef_beta_ortho_scaled  <- coef_beta_ortho / max(abs(coef_beta_ortho))
  coef_gamma_ortho_scaled <- coef_gamma_ortho / max(abs(coef_gamma_ortho))

  # ================================
  # 5. División Train/Valid + centrado
  # ================================
  idx_train <- sample(1:n, size = floor(0.7 * n))
  idx_valid <- setdiff(1:n, idx_train)

  coef_train <- coef_ortho[, idx_train]
  coef_valid <- coef_ortho[, idx_valid]

  mean_train <- rowMeans(coef_train)
  coef_train_centered <- coef_train - mean_train
  coef_valid_centered <- coef_valid - mean_train

  fd_train <- fd(coef_train_centered, basis)
  fd_valid <- fd(coef_valid_centered, basis)

  # ================================
  # 6. Generar etiquetas con alpha balanceado
  # ================================
  psi_ortho <- diag(nbasis)

  # alpha basado en probabilidad media

  alpha_true <- balance_alpha(center.fd(fd_obj_ortho), psi_ortho, coef_beta_ortho_scaled, coef_gamma_ortho_scaled)

  prob_total <- predict_log_func(fd_obj_ortho, psi_ortho,
                                 coef_beta_ortho_scaled, coef_gamma_ortho_scaled, alpha_true)
  y_total <- pred_mod_log_func(prob_total)

  y_train <- y_total[idx_train]
  y_valid <- y_total[idx_valid]

  # ================================
  # 7. Salida
  # ================================
  return(list(
    t = t,
    s = s,
    basis = basis,
    tipo_basis = tipo_basis,

    # matrices ortonormalización
    Psi = Psi,
    M = M,
    Minv = Minv,

    # objetos funcionales
    fd_obj_original = fd_obj,
    fd_obj = fd_obj_ortho,

    coef_original = coef,
    coef_ortho = coef_ortho,

    # betas y gammas normalizados
    coef_beta = coef_beta_ortho_scaled,
    coef_gamma = coef_gamma_ortho_scaled,
    
    alpha = alpha_true,
    beta = beta,
    matriz_beta = matriz_beta,
    matriz_gamma = matriz_gamma,

    idx_train = idx_train,
    idx_valid = idx_valid,
    fd_train = fd_train,
    fd_valid = fd_valid,
    y_train = y_train,
    y_valid = y_valid
  ))
}

```


```{r}
    escenario_denso   <- simular_datos_funcionales(seq(-1, 1, length.out = 201), 3000, nbasis = 100, seed = 123, escenario = "denso")
    escenario_ligero  <- simular_datos_funcionales(seq(-1, 1, length.out = 201), 3000, nbasis = 100, seed = 123, escenario = "ligero")
    
       escenario_ligero_chol  <- simular_datos_funcionales_chol(seq(-1, 1, length.out = 201),1000, nbasis = 100, seed = 123, escenario = "denso")
  
       sum(escenario_ligero_chol$y_train)/length(escenario_ligero_chol$y_train)

```


```{r}
evaluar_modelos_simulados <- function(n = 3000,
                                      nbasis_grid = c(30, 50, 70),
                                      t,
                                      seed = 123,
                                      Lcoef = 2,
                                      tipo_basis="bspline",
                                      chol = FALSE) {
  library(pROC)
  resultados <- data.frame()
  
  for (nbasis in nbasis_grid) {
    cat("====================================\n")
    cat("Simulación con nbasis =", nbasis, "\n")
    cat("====================================\n")
    
    # 1. Simulación densa y ligera
    if (chol) {
      escenario_denso   <- simular_datos_funcionales_chol(t, n, nbasis = nbasis, seed = seed, tipo_basis= tipo_basis, escenario = "denso")
    escenario_ligero  <- simular_datos_funcionales_chol(t, n, nbasis = nbasis, seed = seed, tipo_basis= tipo_basis, escenario = "ligero")
    }
    else{
      
      escenario_denso   <- simular_datos_funcionales(t, n, nbasis = nbasis, seed = seed, tipo_basis= tipo_basis, escenario = "denso")
    escenario_ligero  <- simular_datos_funcionales(t, n, nbasis = nbasis, seed = seed, tipo_basis= tipo_basis, escenario = "ligero")
    }
    
    for (escenario_nombre in c("denso", "ligero")) {
      escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
      
      t <- escenario$t
      basis <- escenario$basis
      fd_train <- escenario$fd_train
      fd_valid <- escenario$fd_valid
      y_valid <- escenario$y_valid
      y_train <- escenario$y_train
      matriz_beta <- escenario$matriz_beta
      matriz_gamma <- escenario$matriz_gamma
      
      psi = inprod(fd_train$basis, fd_train$basis)
      cond_psi <- kappa(psi)
      var_fd_train <- var.fd(fd_train)
      eval_var_fd_train <- eval.bifd(t,t,var_fd_train)
      cond_var_fd_train <- kappa(eval_var_fd_train)
      harmacclLdf <- vec2Lfd(Lcoef, range(t))
      
      # =======================
      # Modelos FPCA (Upsilon0)
      # =======================
      beta_init <- rnorm(nbasis, sd = 0.1)
      gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
      
      modelo_fpca <- fpca_Upsilon0(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 15000,
        var_threshold = 0.8,
        tol = 1e-9,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 1e-4,
        lambda_quad = 0,
                verbose = FALSE

      )
      
      # =======================
      # Modelos FPCA equiv (Upsilon02)
      # =======================
      beta_init <- rnorm(nbasis, sd = 0.1)
      gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
      
      modelo_fpca_equiv <- fpca_upsilon0_equiv(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 15000,
        var_threshold = 0.8,
        tol = 1e-9,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 1e-4,
        lambda_quad = 0,
                verbose = FALSE

      )
      
      # =======================
      # Modelos PCA coef (Upsilon1)
      # =======================
      res_pca_quad <- pca_coef_Upsilon1(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 10000,
        var_threshold = 0.8,
        tol = 1e-9,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 1e-3,
        lambda_quad = 1e-3,
                verbose = FALSE

      )
      
      
      # =======================
      # Cálculo de métricas IMSE
      # =======================
      # Upsilon0
      basis_fpca <- modelo_fpca$fpca_model
      eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
      beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
      gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
      
      imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
      imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)


    psi_half <- Psi_half(psi)
    matriz_diseño_fpca <- t(fd_train$coefs) %*% psi_half
    pca_fpca <- prcomp(matriz_diseño_fpca)

    beta_est_fpca <- as.matrix(pca_fpca$rotation[,1:modelo_fpca$K]) %*% as.vector(modelo_fpca$beta)
    gamma_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$gamma %*% t(pca_fpca$rotation[,1:modelo_fpca$K])
    mse_fpca <- MSEB(escenario$alpha, modelo_fpca$alpha, escenario$coef_beta, beta_est_fpca, escenario$coef_gamma, gamma_est_fpca)
    
      # Upsilon0 equiv
      beta_est_fpca_equiv <- fd(coef = modelo_fpca_equiv$beta, basisobj = basis)
      imseb_beta_fpca_equiv <- IMSEB_integral(eval.fd(fdobj = beta_est_fpca_equiv, evalarg = t), matriz_beta, t)
      evalbasis <- eval.basis(t, basis)
      gamma_est_matriz <- evalbasis %*% modelo_fpca_equiv$gamma %*% t(evalbasis)
      imseb_gamma_fpca_equiv <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
      mse_fpca_equiv = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = modelo_fpca_equiv$beta, gamma_true = escenario$coef_gamma, gamma_hat = modelo_fpca_equiv$gamma)
      
      # Upsilon1
      beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
      imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
      evalbasis <- eval.basis(t, basis)
      gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
      imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
      mse_pca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = res_pca_quad$beta, gamma_true = escenario$coef_gamma, gamma_hat = res_pca_quad$gamma)
      # =======================
      # AUC ROC
      # =======================
      y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
        modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
      )
      y_prob_valid_base_fpca_equiv <- predecir_probabilidades_validacion(
        modelo_fpca_equiv, fd_valid, basis, modo = "PCA"
      )
      y_prob_valid_pca <- predecir_probabilidades_validacion(
        res_pca_quad, fd_valid, basis, modo = "PCA"
      )

      auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
      auc_base_fpca_equiv <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_equiv))
      auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))

      # =======================
      # Guardar resultados
      # =======================
      resultados <- rbind(resultados,
        data.frame(
          escenario = escenario_nombre,
          nbasis = nbasis,
          modelo = "fpca_Upsilon0",
          cuadratico = TRUE,
          AUC = auc_base_fpca,
          IMSE_beta = imseb_beta_fpca,
          IMSE_gamma = imseb_gamma_fpca,
          mse = mse_fpca,
          cond_psi = cond_psi,
          cond_var_fd = cond_var_fd_train
        ),
        data.frame(
          escenario = escenario_nombre,
          nbasis = nbasis,
          modelo = "fpca_Upsilon0_equivalencia",
          cuadratico = TRUE,
          AUC = auc_base_fpca_equiv,
          IMSE_beta = imseb_beta_fpca_equiv,
          IMSE_gamma = imseb_gamma_fpca_equiv,
          mse = mse_fpca_equiv,
          cond_psi = cond_psi,
                    cond_var_fd = cond_var_fd_train

        ),
        data.frame(
          escenario = escenario_nombre,
          nbasis = nbasis,
          modelo = "pca_Upsilon1",
          cuadratico = TRUE,
          AUC = auc_pca,
          IMSE_beta = imseb_beta_pca,
          IMSE_gamma = imseb_gamma_pca,
          mse = mse_pca,
          cond_psi = cond_psi,
                    cond_var_fd = cond_var_fd_train

        )
      )
    }
  }
  
  return(resultados)
}

```



```{r}
resultados_bspline = evaluar_modelos_simulados(3000, c(10,15,30,40,50,60,70,80,90,100), t = seq(-1, 1, length.out = 201), seed = 123, Lcoef = c(3)
)

resultados_bspline_chol = evaluar_modelos_simulados(3000, c(10,15,30,40,50,60,70,80,90,100), t = seq(-1, 1, length.out = 201), seed = 123, Lcoef = c(3), chol = TRUE
)
```




```{r}
library(dplyr)

resultados_bspline <- resultados_bspline %>%
  mutate(
    modelo = case_when(
      modelo == "fpca_Upsilon0" ~ "Upsilon^{(0)}",
      modelo == "fpca_Upsilon0_equivalencia" ~ "Upsilon[Equivalente]^{(0)}",
      modelo == "pca_Upsilon1" ~ "Upsilon^{(1)}",
      TRUE ~ modelo
    )
  )

save(resultados_bspline, file = "resultados_condgram_simulacion_bspline.RData")


resultados_bspline_chol <- resultados_bspline_chol  %>%
  mutate(
    modelo = case_when(
      modelo == "fpca_Upsilon0" ~ "Upsilon^{(0)}",
      modelo == "fpca_Upsilon0_equivalencia" ~ "Upsilon[Equivalente]^{(0)}",
      modelo == "pca_Upsilon1" ~ "Upsilon^{(1)}",
      TRUE ~ modelo
    )
  )

save(resultados_bspline_chol, file = "resultados_condgram_simulacion_bspline_chol.RData")
```

```{r}
library(ggplot2)

# 1. Crear carpeta si no existe
carpeta <- "plots/comparacion modelos numero cond bspline"
if (!dir.exists(carpeta)) {
  dir.create(carpeta)
}

resultados_bspline$base <- "bspline"


p1 <- ggplot(resultados_bspline, aes(x = nbasis, y = AUC, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de AUC según nbasis"),
    x = "nbasis",
    y = "AUC ROC"
  )

ggsave(filename = file.path(carpeta, "AUC_vs_nbasis.png"),
       plot = p1, width = 7, height = 5, dpi = 300)

# ---- PLOT 2 ----
library(ggplot2)
library(dplyr)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_bspline$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_bspline %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = AUC, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  # Se reemplaza ' ' y otros caracteres especiales en el nombre del escenario para el archivo
  nombre_base <- gsub("[^[:alnum:]]", "_", escenario_actual)
  nombre_archivo <- paste0("AUC_vs_cond_psi_", nombre_base, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 4 ----
p4 <- ggplot(resultados_bspline, aes(x = nbasis, y = cond_psi, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(title = "Evolución de cond_psi según nbasis",
       x = "nbasis", y = "kappa(Psi)")

ggsave(filename = file.path(carpeta, "cond_psi_vs_nbasis.png"),
       plot = p4, width = 7, height = 5, dpi = 300)

# ---- PLOT 5 ----
library(ggplot2)
library(dplyr)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_bspline$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_bspline %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot (similar a tu código original, pero sin 'linetype = escenario')
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = mse, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  nombre_archivo <- paste0("msevskappa(psi)_", escenario_actual, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 6 ----
p6 <- ggplot(resultados_bspline, aes(x = nbasis, y = mse, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de MSE según nbasis"),
    x =  "nbasis",
    y = "mse"
  )

ggsave(filename = file.path(carpeta, "nbasis_vs_mse.png"),
       plot = p6, width = 7, height = 5, dpi = 300)
```

```{r}
library(ggplot2)

# 1. Crear carpeta si no existe
carpeta <- "plots/comparacion modelos numero cond bspline cholesky"
if (!dir.exists(carpeta)) {
  dir.create(carpeta)
}

resultados_bspline_chol$base <- "bspline_chol"


p1 <- ggplot(resultados_bspline_chol, aes(x = nbasis, y = AUC, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de AUC según nbasis"),
    x = "nbasis",
    y = "AUC ROC"
  )

ggsave(filename = file.path(carpeta, "AUC_vs_nbasis.png"),
       plot = p1, width = 7, height = 5, dpi = 300)

# ---- PLOT 2 ----
library(ggplot2)
library(dplyr)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_bspline_chol$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_bspline_chol %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = AUC, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  # Se reemplaza ' ' y otros caracteres especiales en el nombre del escenario para el archivo
  nombre_base <- gsub("[^[:alnum:]]", "_", escenario_actual)
  nombre_archivo <- paste0("AUC_vs_cond_psi_", nombre_base, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 4 ----
p4 <- ggplot(resultados_bspline_chol, aes(x = nbasis, y = cond_psi, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(title = "Evolución de cond_psi según nbasis",
       x = "nbasis", y = "kappa(Psi)")

ggsave(filename = file.path(carpeta, "cond_psi_vs_nbasis.png"),
       plot = p4, width = 7, height = 5, dpi = 300)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_bspline_chol$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_bspline_chol %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot (similar a tu código original, pero sin 'linetype = escenario')
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = mse, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  nombre_archivo <- paste0("msevskappa(psi)_", escenario_actual, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 6 ----
p6 <- ggplot(resultados_bspline_chol, aes(x = nbasis, y = mse, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de MSE según nbasis"),
    x =  "nbasis",
    y = "mse"
  )

ggsave(filename = file.path(carpeta, "nbasis_vs_mse.png"),
       plot = p6, width = 7, height = 5, dpi = 300)
```

```{r}

resultados_fourier = evaluar_modelos_simulados(3000, c(11,15,31,41,51,61,71,81,91), t = seq(-1, 1, length.out = 301), seed = 123, Lcoef = c(3), tipo_basis = "fourier"
)
```

```{r}
library(dplyr)

resultados_fourier <- resultados_fourier %>%
  mutate(
    modelo = case_when(
      modelo == "fpca_Upsilon0" ~ "Upsilon^{(0)}",
      modelo == "fpca_Upsilon0_equivalencia" ~ "Upsilon[Equivalente]^{(0)}",
      modelo == "pca_Upsilon1" ~ "Upsilon^{(1)}",
      TRUE ~ modelo
    )
  )

save(resultados_fourier, file = "resultados_condgram_simulacion_fourier.RData")
```

```{r}
library(ggplot2)

# 1. Crear carpeta si no existe
carpeta <- "plots/comparacion modelos numero cond fourier"
if (!dir.exists(carpeta)) {
  dir.create(carpeta)
}

library(ggplot2)

p1 <- ggplot(resultados_bspline, aes(x = nbasis, y = AUC, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de AUC según nbasis"),
    x = "nbasis",
    y = "AUC ROC"
  )

ggsave(filename = file.path(carpeta, "AUC_vs_nbasis.png"),
       plot = p1, width = 7, height = 5, dpi = 300)

# ---- PLOT 2 ----
library(ggplot2)
library(dplyr)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_fourier$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_fourier %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = AUC, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  # Se reemplaza ' ' y otros caracteres especiales en el nombre del escenario para el archivo
  nombre_base <- gsub("[^[:alnum:]]", "_", escenario_actual)
  nombre_archivo <- paste0("AUC_vs_cond_psi_", nombre_base, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 4 ----
p4 <- ggplot(resultados_fourier, aes(x = nbasis, y = AUC, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(title = "Evolución de AUC ROC según nbasis",
       x = "nbasis", y = "AUC ROC")

ggsave(filename = file.path(carpeta, "aucroc_vs_nbasis.png"),
       plot = p4, width = 7, height = 5, dpi = 300)

# ---- PLOT 5 ----
library(ggplot2)
library(dplyr)

# Obtener los nombres únicos de los escenarios
escenarios_unicos <- unique(resultados_fourier$escenario)

# Iterar sobre cada escenario único y generar un plot
for (escenario_actual in escenarios_unicos) {
  
  # 1. Filtrar los datos para el escenario actual
  datos_filtrados <- resultados_fourier %>%
    filter(escenario == escenario_actual)
  
  # 2. Generar el plot (similar a tu código original, pero sin 'linetype = escenario')
  p_escenario <- ggplot(datos_filtrados, aes(x = cond_psi, y = mse, color = modelo)) +
    geom_line(size = 1.2) +
    geom_point() +
    # Usamos scale_color_discrete para interpretar las etiquetas de los modelos
    scale_color_discrete(labels = function(x) parse(text = x)) +
    theme_minimal() +
    labs(
      # Título adaptado para incluir el nombre del escenario
      title = expression(paste("Evolución de AUC según ", kappa(Psi), " - Escenario: ", escenario_actual)),
      x = expression(kappa(Psi)),
      y = "AUC ROC",
      color = "Modelo"
    )
  
  # 3. Guardar el plot con un nombre de archivo específico para el escenario
  nombre_archivo <- paste0("msevskappa(psi)_", escenario_actual, ".png")
  
  ggsave(filename = file.path(carpeta, nombre_archivo),
         plot = p_escenario, width = 7, height = 5, dpi = 300)
  
  cat("Gráfico guardado para el escenario:", escenario_actual, "\n")
}
# ---- PLOT 6 ----
p6 <- ggplot(resultados_fourier, aes(x = nbasis, y = mse, color = modelo ,linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  scale_color_discrete(labels = function(x) parse(text = x)) +
  theme_minimal() +
  labs(
    title = expression("Evolución de MSE según nbasis"),
    x =  "nbasis",
    y = "mse"
  )

ggsave(filename = file.path(carpeta, "nbasis_vs_mse.png"),
       plot = p6, width = 7, height = 5, dpi = 300)
```












