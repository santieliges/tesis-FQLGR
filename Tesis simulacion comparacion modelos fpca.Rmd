---
title: "Simulacion comparacion modelos pca"
author: "santiago eliges"
date: "2025-11-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
source("FQLGR.R")

```

#Comparciòn modelos FPCA
Acá comparo a los modelos basados en componentes principales (Upsilon 0 y 1) cambiando el tamaño de nbasis con misma var treshold (esto podría ser engañoso... Quizá es una comparación injusta comparar con mismo var_treshold en vez de comprar con el mejor para cada uno, pero tambien es interesante comprar como cambian con la misma información explicada. Con esto quiero decir que si en un modelo se consiguen mejores resultados con menos componentes, es posible que sea por que las componentes tienen mucho más ruido y estaria bueno que eso quede también registrado)

```{r}
# =====================================================================
# Funciones Auxiliares para Simulación y Predicción
# =====================================================================


# Funciones auxiliares ---------------------------------------------------

# Regla del trapecio 1D (para vectores x,y)
trapz1d <- function(x, y) {
  if (length(x) != length(y)) stop("x e y deben tener la misma longitud")
  idx <- 2:length(x)
  sum((x[idx] - x[idx - 1]) * (y[idx] + y[idx - 1])) / 2
}

# Integración doble por trapecio (asume matriz Z with rows correspond to s, cols to t)
trapz2d <- function(s, t, Z) {
  if (!all(dim(Z) == c(length(s), length(t)))) {
    stop("Dimensiones de Z deben ser length(s) x length(t)")
  }
  # Integramos respecto a t en cada fila -> vector de longitud length(s)
  int_t_by_row <- apply(Z, 1, function(row) trapz1d(t, row))
  # Integramos el resultado respecto a s
  trapz1d(s, int_t_by_row)
}

# IMSEB univariado -------------------------------------------------------

# beta_true / beta_hat pueden ser:
#  - vectores evaluados en la grilla t
#  - objetos 'fd' de package fda (en cuyo caso se evalúan en una grilla fina)
IMSEB_integral <- function(beta_true, beta_hat, t = NULL, grid_n = 201) {
  # Si son objetos fd, evaluarlos en grilla
  if (inherits(beta_true, "fd") || inherits(beta_hat, "fd")) {
    if (!requireNamespace("fda", quietly = TRUE)) {
      stop("Para pasar objetos 'fd' necesitas instalar paquete 'fda'")
    }
    if (is.null(t)) {
      rng <- beta_true$basis$rangeval
      t <- seq(rng[1], rng[2], length.out = grid_n)
    }
    y_true <- as.numeric(fda::eval.fd(t, beta_true))
    y_hat  <- as.numeric(fda::eval.fd(t, beta_hat))
  } else {
    # beta_true/hat deben ser vectores y se requiere t
    if (is.null(t)) stop("Si pasás vectores debes pasar el vector 't' con la grilla")
    y_true <- as.numeric(beta_true)
    y_hat  <- as.numeric(beta_hat)
    if (length(y_true) != length(t) || length(y_hat) != length(t)) {
      stop("Dimensiones de beta_true/beta_hat deben coincidir con length(t)")
    }
  }
  
  diff2 <- (y_true - y_hat)^2
  integral <- trapz1d(t, diff2)
  T_len <- max(t) - min(t)
  return(as.numeric(integral / T_len))
}

# IMBSEB bivariado -------------------------------------------------------

# Modo A: entradas discretizadas (matrices Z_true, Z_hat) sobre grilla s,t
IMBSEB_integral_grid <- function(Z_true, Z_hat, s, t) {
  if (!all(dim(Z_true) == dim(Z_hat))) stop("Z_true y Z_hat deben tener mismas dimensiones")
  if (!all(dim(Z_true) == c(length(s), length(t)))) stop("Dimensiones de Z_true deben ser length(s) x length(t)")
  
  diff2 <- (Z_true - Z_hat)^2
  integral_xy <- trapz2d(s, t, diff2)
  area <- (max(s) - min(s)) * (max(t) - min(t))
  return(as.numeric(integral_xy / area))
}

# Modo B: entradas en coeficientes de base (A_true, A_hat) y matrices Gram Psi_s, Psi_t
IMBSEB_coef_Kron <- function(A_true, A_hat, Psi_s, Psi_t, s_range = c(0,1), t_range = c(0,1)) {
  # A_true, A_hat : Ks x Kt matrices de coeficientes
  if (!all(dim(A_true) == dim(A_hat))) stop("A_true y A_hat deben tener mismas dimensiones")
  Ks <- nrow(A_true); Kt <- ncol(A_true)
  if (!all(dim(Psi_s) == c(Ks, Ks))) stop("Psi_s debe ser Ks x Ks")
  if (!all(dim(Psi_t) == c(Kt, Kt))) stop("Psi_t debe ser Kt x Kt")
  
  d <- as.vector(A_true - A_hat) # vectorización (col-major por defecto en R)
  Kmat <- kronecker(Psi_t, Psi_s) # (Ks*Kt) x (Ks*Kt)
  area <- (s_range[2] - s_range[1]) * (t_range[2] - t_range[1])
  val <- as.numeric(t(d) %*% Kmat %*% d) / area
  return(val)
}

# Función wrapper que intenta elegir modo apropiado
IMBSEB <- function(gamma_true, gamma_hat, s = NULL, t = NULL, 
                   A_mode = FALSE, Psi_s = NULL, Psi_t = NULL, s_range = NULL, t_range = NULL) {
  # Si A_mode = TRUE se usan coeficientes A_true/A_hat y Psi matrices
  if (A_mode) {
    if (is.null(Psi_s) || is.null(Psi_t)) stop("En modo coeficientes necesitás Psi_s y Psi_t")
    if (is.null(s_range) || is.null(t_range)) stop("s_range y t_range necesarios en modo coeficientes")
    return(IMBSEB_coef_Kron(gamma_true, gamma_hat, Psi_s, Psi_t, s_range, t_range))
  } else {
    # gamma_true/hat deben ser matrices en grilla y s,t provistos
    if (is.null(s) || is.null(t)) stop("Debés pasar s y t (grillas) para el modo grid")
    return(IMBSEB_integral_grid(gamma_true, gamma_hat, s, t))
  }
}

# MSEB -------------------------------------------------------
# Calcula el MSEB definido como:
# (1/(p+1))*[(alpha - alpha_hat)^2 + sum_j (beta_j - beta_hat_j)^2] +
# (1/p^2)*sum_{k,l} (gamma_{k,l} - gamma_hat_{k,l})^2
MSEB <- function(alpha_true, alpha_hat,
                 beta_true, beta_hat,
                 gamma_true, gamma_hat) {
  
  # --- Comprobaciones básicas ---
  if (!is.numeric(alpha_true) || !is.numeric(alpha_hat))
    stop("alpha_true y alpha_hat deben ser escalares numéricos")
  
  if (length(beta_true) != length(beta_hat))
    stop("beta_true y beta_hat deben tener la misma longitud")
  
  if (!all(dim(gamma_true) == dim(gamma_hat)))
    stop("gamma_true y gamma_hat deben tener las mismas dimensiones")
  
  p <- length(beta_true)  # número de covariables funcionales
  
  # --- Cálculo de componentes ---
  term_alpha <- (alpha_true - alpha_hat)^2
  
  term_beta <- sum((beta_true - beta_hat)^2)
  
  term_gamma <- sum((gamma_true - gamma_hat)^2)
  
  # --- MSEB total ---
  mse_b <- (1 / (p + 1)) * (term_alpha + term_beta) +
    (1 / (p^2))   * term_gamma
  
  return(as.numeric(mse_b))
}


predict_log_func <- function(fd_centered, psi, coef_beta, coef_gamma, alpha) {
  n <- dim(fd_centered$coefs)[2]
  probs <- numeric(n)
  for (i in 1:n) {
    lin_part <- fd_centered$coefs[,i] %*% psi %*% coef_beta
    quad_part <- fd_centered$coefs[,i] %*% psi %*% coef_gamma %*% psi %*% fd_centered$coefs[,i]
    modelo_lineal <- alpha + lin_part + quad_part
    probs[i] <- 1 / (1 + exp(-modelo_lineal))
  }
  return(probs)
}

pred_mod_log_func <- function(prob_true) {
  rbinom(length(prob_true), size = 1, prob = prob_true)
}

balance_alpha <- function(fd_centered, psi, coef_beta, coef_gamma, target = 0.5) {
  f <- function(alpha) {
    probs <- predict_log_func(fd_centered, psi, coef_beta, coef_gamma, alpha)
    mean(probs) - target
  }
  uniroot(f, c(-50, 50))$root
}
```


```{r}
simular_datos_funcionales <- function(t, n = 3000, nbasis = 50, seed = 123) {
  library(fda)
  library(MASS)
  
  set.seed(seed)
  rangeval <- range(t)
  
  # ================================
  # 1. Base B-spline
  # ================================
  internal_breaks <- seq(rangeval[1], rangeval[2], length.out = nbasis - 1)
  basis <- create.bspline.basis(
    rangeval = rangeval,
    breaks = internal_breaks,
    nbasis = nbasis,
    norder = nbasis + 2 - length(internal_breaks)
  )
  
  # ================================
  # 2. Coeficientes correlacionados (AR(1))
  # ================================
  mean_coef <- rnorm(nbasis, sd = seq(1, nbasis) / nbasis)
  rho <- 0.8
  Sigma <- outer(1:nbasis, 1:nbasis, function(i, j) rho^abs(i - j))
  Sigma <- Sigma * diag(seq(nbasis, 1))
  
  coef <- mvrnorm(n, mu = mean_coef, Sigma = Sigma)
  fd_obj <- fd(coef = t(coef), basisobj = basis)
  
  # Centrado
  fd_centered <- center.fd(fd_obj)
  
  # ================================
  # 3. Coeficientes verdaderos (β(t), γ(s,t))
  # ================================
  s <- t
  beta <- 2 * sin(2 * pi * t) + 0.5 * cos(4 * pi * t)
  matriz_beta <- beta / max(abs(beta))
  
  Sigma_gamma <- 0.6
  matriz_gamma <- outer(s, t, function(s, t) {
    exp(-((s - t)^2) / (2 * Sigma_gamma^2)) + 0.5 * sin(pi * s) * sin(pi * t)
  })
  matriz_gamma <- (matriz_gamma + t(matriz_gamma)) / 2
  
  # ================================
  # 4. Proyección sobre base B-spline
  # ================================
  fd_beta <- Data2fd(argvals = t, y = matriz_beta, basisobj = basis)
  coef_beta <- fd_beta$coefs
  
  Phi_s <- eval.basis(s, basis)
  Phi_t <- eval.basis(t, basis)
  
  A <- t(Phi_s) %*% matriz_gamma %*% Phi_t
  G_s <- t(Phi_s) %*% Phi_s
  G_t <- t(Phi_t) %*% Phi_t
  
  A_est <- solve(G_s) %*% A %*% solve(G_t)
  coef_gamma <- (A_est + t(A_est)) / 2
  
  gamma_recon <- Phi_s %*% A_est %*% t(Phi_t)
  
  # ================================
  # 5. División en entrenamiento/validación
  # ================================
  psi <- inprod(basis, basis)
  idx_train <- sample(1:n, size = floor(0.7 * n))
  idx_valid <- setdiff(1:n, idx_train)
  
  fd_train <- fd(fd_centered$coefs[, idx_train], basis)
  fd_valid <- fd(fd_centered$coefs[, idx_valid], basis)
  
  # =================================
  # 5.prediccion
  #======================
  
  set.seed(123)

  alpha_true <- balance_alpha(center.fd(fd_obj), psi, coef_beta, coef_gamma)

  prob_total <- predict_log_func(center.fd(fd_obj), psi, coef_beta, coef_gamma, alpha_true)
  y_total <- pred_mod_log_func(prob_total)
  
  y_train <- y_total[idx_train]
  y_valid <- y_total[idx_valid]
  
  # ================================
  # 6. Salida
  # ================================
  return(list(
    t = t,
    s = s,
    basis = basis,
    fd_obj = fd_obj,
    fd_centered = fd_centered,
    coef = coef,
    alpha = alpha_true,
    coef_beta = coef_beta,
    coef_gamma = coef_gamma,
    beta = beta,
    matriz_beta = matriz_beta,
    matriz_gamma = matriz_gamma,
    gamma_recon = gamma_recon,
    idx_train = idx_train,
    idx_valid = idx_valid,
    fd_train = fd_train,
    y_train = y_train,
    fd_valid = fd_valid,
    y_valid = y_valid,
    psi = psi
  ))
}
```

```{r}
    escenario_denso   <- simular_datos_funcionales(seq(-1, 1, length.out = 101), 3000, nbasis = 15, seed = 123)
    escenario_ligero  <- simular_datos_funcionales(seq(-1, 1, length.out = 2001), 3000, nbasis = 15, seed = 123)
    
```


```{r}
evaluar_modelos_simulados <- function(n = 3000,
                                      nbasis_grid = c(30, 50, 70),
                                      t_denso,
                                      t_ligero,
                                      seed = 123,
                                      Lcoef = 2) {
  library(pROC)
  resultados <- data.frame()
  
  for (nbasis in nbasis_grid) {
    cat("====================================\n")
    cat("Simulación con nbasis =", nbasis, "\n")
    cat("====================================\n")
    
    # 1. Simulación densa y ligera
    escenario_denso   <- simular_datos_funcionales(t_denso, n, nbasis = nbasis, seed = seed)
    escenario_ligero  <- simular_datos_funcionales(t_ligero, n, nbasis = nbasis, seed = seed)
    
    for (escenario_nombre in c("denso", "ligero")) {
      escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
      
      t <- escenario$t
      basis <- escenario$basis
      fd_train <- escenario$fd_train
      fd_valid <- escenario$fd_valid
      y_valid <- escenario$y_valid
      print(y_valid)
      y_train <- escenario$y_train
      print(y_train)
      matriz_beta <- escenario$matriz_beta
      matriz_gamma <- escenario$matriz_gamma
    
      harmacclLdf <- vec2Lfd(Lcoef, range(t))
      
      # =======================
      # Modelos FPCA (Upsilon0)
      # =======================
      beta_init <- rnorm(nbasis, sd = 0.1)
      gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
      
      modelo_fpca <- fpca_Upsilon0(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 15000,
        var_threshold = 0.7,
        tol = 1e-8,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 1e-4,
        lambda_quad = 0,
                verbose = FALSE

      )
      
      modelo_fpca_lin <- fpca_Upsilon0(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 15000,
        var_threshold = 0.7,
        tol = 1e-8,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 1e-4,
        lambda_quad = 0,
        modelo_quad = FALSE,
                verbose = FALSE

      )
      
      # =======================
      # Modelos PCA coef (Upsilon1)
      # =======================
      res_pca_quad <- pca_coef_Upsilon1(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 10000,
        var_threshold = 0.7,
        tol = 1e-8,
        basis = basis,
        LdPenalization = harmacclLdf,
        lambda_lin = 0,
        lambda_quad = 0,
                verbose = FALSE

      )
      
      res_pca_noquad <- pca_coef_Upsilon1(
        fd_centered = fd_train,
        y = y_train,
        beta = beta_init,
        gamma = gamma_init,
        alpha = 0,
        step_gradient = 0.005,
        iterations = 10000,
        var_threshold = 0.7,
        basis = basis,
        tol = 1e-8,
        LdPenalization = harmacclLdf,
        lambda_lin = 0,
        lambda_quad = 0,
        modelo_quad = FALSE,
        verbose = FALSE
      )
      
      # =======================
      # Cálculo de métricas IMSE
      # =======================
      # Upsilon0
      basis_fpca <- modelo_fpca$fpca_model
      eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
      beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
      gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
      
      imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
      imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
      psi = inprod(fd_train$basis, fd_train$basis)
    eig <- eigen(psi)
    psi_half <- eig$vectors %*% diag(sqrt(eig$values)) %*% t(eig$vectors)
    matriz_diseño_fpca <- t(fd_train$coefs) %*% psi_half
    pca_fpca <- prcomp(matriz_diseño_fpca)
    beta_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$beta
    gamma_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$gamma %*% t(pca_fpca$rotation[,1:modelo_fpca$K])
    mse_fpca <- MSEB(escenario$alpha, modelo_fpca$alpha, escenario$coef_beta, beta_est_fpca, escenario$coef_gamma, gamma_est_fpca)
      
      # Upsilon1
      beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
      imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
      evalbasis <- eval.basis(t, basis)
      gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
      imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
      print(escenario$alpha)
      mse_pca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = res_pca_quad$beta, gamma_true = escenario$coef_gamma, gamma_hat = res_pca_quad$gamma)
      # =======================
      # AUC ROC
      # =======================
      y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
        modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
      )
      y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
        modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
      )
      y_prob_valid_pca <- predecir_probabilidades_validacion(
        res_pca_quad, fd_valid, basis, modo = "PCA"
      )
      y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
        res_pca_noquad, fd_valid, basis, modo = "PCA"
      )
      
      auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
      auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
      auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
      auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
      
      # =======================
      # Guardar resultados
      # =======================
      resultados <- rbind(resultados,
        data.frame(
          escenario = escenario_nombre,
          nbasis = nbasis,
          modelo = "fpca_Upsilon0",
          cuadratico = TRUE,
          AUC = auc_base_fpca,
          IMSE_beta = imseb_beta_fpca,
          IMSE_gamma = imseb_gamma_fpca,
          mse = mse_fpca
        ),
        data.frame(
          escenario = escenario_nombre,
          nbasis = nbasis,
          modelo = "pca_Upsilon1",
          cuadratico = TRUE,
          AUC = auc_pca,
          IMSE_beta = imseb_beta_pca,
          IMSE_gamma = imseb_gamma_pca,
          mse = mse_pca
        )
      )
    }
  }
  
  return(resultados)
}

```

```{r}
resultados = evaluar_modelos_simulados(3000, c(10,15,30,50,80,100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
```


```{r}
library(ggplot2)

ggplot(resultados, aes(x = nbasis, y = AUC, color = modelo, linetype = escenario)) +
  geom_line(size = 1.2) +
  geom_point() +
  theme_minimal() +
  labs(title = "Evolución de AUC según nbasis",
       x = "nbasis", y = "AUC ROC")

ggplot(resultados, aes(x = nbasis, y = IMSE_beta, color = modelo, linetype = escenario)) +
  geom_line(size = 1.2) +
  theme_minimal() +
  labs(title = "Evolución del IMSE(β)", x = "nbasis", y = "IMSE β")

resultados$IMSE_beta

ggplot(resultados, aes(x = nbasis, y = IMSE_gamma, color = modelo, linetype = escenario)) +
  geom_line(size = 1.2) +
  theme_minimal() +
  labs(title = "Evolución del IMSE(gamma)", x = "nbasis", y = "IMSE gamma")

resultados$IMSE_gamma

ggplot(resultados, aes(x = nbasis, y = mse, color = modelo, linetype = escenario)) +
  geom_line(size = 1.2) +
  theme_minimal() +
  labs(title = "Evolución del mse", x = "nbasis", y = "MSE")

resultados$mse
```














