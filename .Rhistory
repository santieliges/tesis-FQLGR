res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.05,
iterations = 10000,
var_threshold = 0.9,
basis = basis,
tol = 1e-7,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 1e-4,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
print(dim(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs)))
beta_coef_en_basis <- as.vector(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs))
gamma_coef_en_basis <- modelo_fpca$fpca_model$harmonics$coefs %*% modelo_fpca$gamma %*% t(modelo_fpca$fpca_model$harmonics$coefs)
mse_fpca <- MSEB(coef_alpha, modelo_fpca$alpha, coef_beta, beta_coef_en_basis, coef_gamma, gamma_coef_en_basis)
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
mse_pca <- MSEB(coef_alpha, res_pca_quad$alpha, coef_beta, res_pca_quad$beta, coef_gamma, res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(8,20,30,40,50,60, 70, 80, 100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
library(ggplot2)
ggplot(resultados, aes(x = nbasis, y = AUC, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
geom_point() +
theme_minimal() +
labs(title = "Evolución de AUC según nbasis",
x = "nbasis", y = "AUC ROC")
ggplot(resultados, aes(x = nbasis, y = IMSE_gamma, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = mse, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = cond_Psi, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
# ==================================
# Función que crea los dos escenarios y para distintos nbasis entrena los modelos y guarda las métricas
# ==================================
evaluar_modelos_simulados <- function(n = 3000,
nbasis_grid = c(30, 50, 70),
t_denso,
t_ligero,
seed = 123,
Lcoef = 2) {
library(pROC)
resultados <- data.frame()
for (nbasis in nbasis_grid) {
cat("====================================\n")
cat("Simulación con nbasis =", nbasis, "\n")
cat("====================================\n")
# 1. Simulación densa y ligera
escenario_denso   <- simular_datos_funcionales(t_denso, n, nbasis = nbasis, seed = seed)
escenario_ligero  <- simular_datos_funcionales(t_ligero, n, nbasis = nbasis, seed = seed)
for (escenario_nombre in c("denso", "ligero")) {
escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
t <- escenario$t
basis <- escenario$basis
fd_train <- escenario$fd_train
fd_valid <- escenario$fd_valid
y_valid <- escenario$y_valid
y_train <- escenario$y_train
matriz_beta <- escenario$matriz_beta
matriz_gamma <- escenario$matriz_gamma
coef_alpha <- escenario$alpha
coef_beta <- escenario$coef_beta
coef_gamma <- escenario$coef_gamma
harmacclLdf <- vec2Lfd(Lcoef, range(t))
# ================================
# >>> AGREGADO: número de condición Psi
# ================================
Psi <- inprod(basis, basis)
cond_number <- kappa(Psi)
# =======================
# Modelos FPCA (Upsilon0)
# =======================
beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
modelo_fpca <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.001,
iterations = 15000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-2,
lambda_quad = 1e-4,
verbose = FALSE
)
modelo_fpca_lin <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.001,
iterations = 15000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 1e-4,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Modelos PCA coef (Upsilon1)
# =======================
res_pca_quad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.05,
iterations = 10000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-3,
lambda_quad = 1e-4,
verbose = FALSE
)
res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.05,
iterations = 10000,
var_threshold = 0.8,
basis = basis,
tol = 1e-7,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 1e-4,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
print(dim(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs)))
beta_coef_en_basis <- as.vector(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs))
gamma_coef_en_basis <- modelo_fpca$fpca_model$harmonics$coefs %*% modelo_fpca$gamma %*% t(modelo_fpca$fpca_model$harmonics$coefs)
mse_fpca <- MSEB(coef_alpha, modelo_fpca$alpha, coef_beta, beta_coef_en_basis, coef_gamma, gamma_coef_en_basis)
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
mse_pca <- MSEB(coef_alpha, res_pca_quad$alpha, coef_beta, res_pca_quad$beta, coef_gamma, res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(8,20,30,40,50,60, 70, 80, 100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
library(ggplot2)
ggplot(resultados, aes(x = nbasis, y = AUC, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
geom_point() +
theme_minimal() +
labs(title = "Evolución de AUC según nbasis",
x = "nbasis", y = "AUC ROC")
ggplot(resultados, aes(x = nbasis, y = IMSE_gamma, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = mse, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = cond_Psi, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
source("FQLGR.R")
# ==================================
# Función que crea los dos escenarios y para distintos nbasis entrena los modelos y guarda las métricas
# ==================================
evaluar_modelos_simulados <- function(n = 3000,
nbasis_grid = c(30, 50, 70),
t_denso,
t_ligero,
seed = 123,
Lcoef = 2) {
library(pROC)
resultados <- data.frame()
for (nbasis in nbasis_grid) {
cat("====================================\n")
cat("Simulación con nbasis =", nbasis, "\n")
cat("====================================\n")
# 1. Simulación densa y ligera
escenario_denso   <- simular_datos_funcionales(t_denso, n, nbasis = nbasis, seed = seed)
escenario_ligero  <- simular_datos_funcionales(t_ligero, n, nbasis = nbasis, seed = seed)
for (escenario_nombre in c("denso", "ligero")) {
escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
t <- escenario$t
basis <- escenario$basis
fd_train <- escenario$fd_train
fd_valid <- escenario$fd_valid
y_valid <- escenario$y_valid
y_train <- escenario$y_train
matriz_beta <- escenario$matriz_beta
matriz_gamma <- escenario$matriz_gamma
coef_alpha <- escenario$alpha
coef_beta <- escenario$coef_beta
coef_gamma <- escenario$coef_gamma
harmacclLdf <- vec2Lfd(Lcoef, range(t))
# ================================
# >>> AGREGADO: número de condición Psi
# ================================
Psi <- inprod(basis, basis)
cond_number <- kappa(Psi)
# =======================
# Modelos FPCA (Upsilon0)
# =======================
beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
modelo_fpca <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.001,
iterations = 15000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-2,
lambda_quad = 1e-4,
verbose = FALSE
)
modelo_fpca_lin <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.001,
iterations = 15000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 1e-4,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Modelos PCA coef (Upsilon1)
# =======================
res_pca_quad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.05,
iterations = 10000,
var_threshold = 0.8,
tol = 1e-7,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-3,
lambda_quad = 1e-4,
scale = FALSE,
verbose = FALSE
)
res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.05,
iterations = 10000,
var_threshold = 0.8,
basis = basis,
tol = 1e-7,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 1e-4,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
print(dim(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs)))
beta_coef_en_basis <- as.vector(modelo_fpca$beta %*% t(modelo_fpca$fpca_model$harmonics$coefs))
gamma_coef_en_basis <- modelo_fpca$fpca_model$harmonics$coefs %*% modelo_fpca$gamma %*% t(modelo_fpca$fpca_model$harmonics$coefs)
mse_fpca <- MSEB(coef_alpha, modelo_fpca$alpha, coef_beta, beta_coef_en_basis, coef_gamma, gamma_coef_en_basis)
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
mse_pca <- MSEB(coef_alpha, res_pca_quad$alpha, coef_beta, res_pca_quad$beta, coef_gamma, res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
cond_Psi = cond_number,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(8,20,30,40,50,60, 70, 80, 100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
library(ggplot2)
ggplot(resultados, aes(x = nbasis, y = AUC, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
geom_point() +
theme_minimal() +
labs(title = "Evolución de AUC según nbasis",
x = "nbasis", y = "AUC ROC")
ggplot(resultados, aes(x = nbasis, y = IMSE_gamma, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = mse, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
ggplot(resultados, aes(x = nbasis, y = cond_Psi, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del MSE", x = "nbasis", y = "MSE")
