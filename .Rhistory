alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
verbose = FALSE
)
modelo_fpca_lin <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Modelos PCA coef (Upsilon1)
# =======================
res_pca_quad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
verbose = FALSE
)
res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
basis = basis,
tol = 1e-8,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
# Upsilon0
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
print(escenario$coef_beta)
print(modelo_fpca$beta)
mse_fpca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = modelo_fpca$beta, gamma_true = escenario$coef_gamma, gamma_hat = modelo_fpca$gamma)
# Upsilon1
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(escenario$alpha)
mse_pca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = res_pca_quad$beta, gamma_true = escenario$coef_gamma, gamma_hat = res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(10,15,30,50,80,100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
evaluar_modelos_simulados <- function(n = 3000,
nbasis_grid = c(30, 50, 70),
t_denso,
t_ligero,
seed = 123,
Lcoef = 2) {
library(pROC)
resultados <- data.frame()
for (nbasis in nbasis_grid) {
cat("====================================\n")
cat("Simulación con nbasis =", nbasis, "\n")
cat("====================================\n")
# 1. Simulación densa y ligera
escenario_denso   <- simular_datos_funcionales(t_denso, n, nbasis = nbasis, seed = seed)
escenario_ligero  <- simular_datos_funcionales(t_ligero, n, nbasis = nbasis, seed = seed)
for (escenario_nombre in c("denso", "ligero")) {
escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
t <- escenario$t
basis <- escenario$basis
fd_train <- escenario$fd_train
fd_valid <- escenario$fd_valid
y_valid <- escenario$y_valid
print(y_valid)
y_train <- escenario$y_train
print(y_train)
matriz_beta <- escenario$matriz_beta
matriz_gamma <- escenario$matriz_gamma
harmacclLdf <- vec2Lfd(Lcoef, range(t))
# =======================
# Modelos FPCA (Upsilon0)
# =======================
beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
modelo_fpca <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
verbose = FALSE
)
modelo_fpca_lin <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Modelos PCA coef (Upsilon1)
# =======================
res_pca_quad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
verbose = FALSE
)
res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
basis = basis,
tol = 1e-8,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
# Upsilon0
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
eig <- eigen(psi)
psi_half <- eig$vectors %*% diag(sqrt(eig$values)) %*% t(eig$vectors)
matriz_diseño_fpca <- t(fd_train$coefs) %*% psi_half
pca_fpca <- prcomp(matriz_diseño_fpca)
beta_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$beta
gamma_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$gamma %*% t(pca_fpca$rotation[,1:modelo_fpca$K])
mse_fpca <- MSEB(escenario$alpha, modelo_fpca$alpha, escenario$coef_beta, beta_est_fpca, escenario$coef_gamma, gamma_est_fpca)
# Upsilon1
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(escenario$alpha)
mse_pca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = res_pca_quad$beta, gamma_true = escenario$coef_gamma, gamma_hat = res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(10,15,30,50,80,100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
evaluar_modelos_simulados <- function(n = 3000,
nbasis_grid = c(30, 50, 70),
t_denso,
t_ligero,
seed = 123,
Lcoef = 2) {
library(pROC)
resultados <- data.frame()
for (nbasis in nbasis_grid) {
cat("====================================\n")
cat("Simulación con nbasis =", nbasis, "\n")
cat("====================================\n")
# 1. Simulación densa y ligera
escenario_denso   <- simular_datos_funcionales(t_denso, n, nbasis = nbasis, seed = seed)
escenario_ligero  <- simular_datos_funcionales(t_ligero, n, nbasis = nbasis, seed = seed)
for (escenario_nombre in c("denso", "ligero")) {
escenario <- if (escenario_nombre == "denso") escenario_denso else escenario_ligero
t <- escenario$t
basis <- escenario$basis
fd_train <- escenario$fd_train
fd_valid <- escenario$fd_valid
y_valid <- escenario$y_valid
print(y_valid)
y_train <- escenario$y_train
print(y_train)
matriz_beta <- escenario$matriz_beta
matriz_gamma <- escenario$matriz_gamma
harmacclLdf <- vec2Lfd(Lcoef, range(t))
# =======================
# Modelos FPCA (Upsilon0)
# =======================
beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
modelo_fpca <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
verbose = FALSE
)
modelo_fpca_lin <- fpca_Upsilon0(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 15000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 1e-4,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Modelos PCA coef (Upsilon1)
# =======================
res_pca_quad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
tol = 1e-8,
basis = basis,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
verbose = FALSE
)
res_pca_noquad <- pca_coef_Upsilon1(
fd_centered = fd_train,
y = y_train,
beta = beta_init,
gamma = gamma_init,
alpha = 0,
step_gradient = 0.005,
iterations = 10000,
var_threshold = 0.7,
basis = basis,
tol = 1e-8,
LdPenalization = harmacclLdf,
lambda_lin = 0,
lambda_quad = 0,
modelo_quad = FALSE,
verbose = FALSE
)
# =======================
# Cálculo de métricas IMSE
# =======================
# Upsilon0
basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj = basis_fpca$harmonics)
beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis)
imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
psi = inprod(fd_train$basis, fd_train$basis)
eig <- eigen(psi)
psi_half <- eig$vectors %*% diag(sqrt(eig$values)) %*% t(eig$vectors)
matriz_diseño_fpca <- t(fd_train$coefs) %*% psi_half
pca_fpca <- prcomp(matriz_diseño_fpca)
beta_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$beta
gamma_est_fpca <- pca_fpca$rotation[,1:modelo_fpca$K] %*% modelo_fpca$gamma %*% t(pca_fpca$rotation[,1:modelo_fpca$K])
mse_fpca <- MSEB(escenario$alpha, modelo_fpca$alpha, escenario$coef_beta, beta_est_fpca, escenario$coef_gamma, gamma_est_fpca)
# Upsilon1
beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
evalbasis <- eval.basis(t, basis)
gamma_est_matriz <- evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(escenario$alpha)
mse_pca = MSEB(alpha_true = escenario$alpha, alpha_hat = modelo_fpca$alpha, beta_true = escenario$coef_beta, beta_hat = res_pca_quad$beta, gamma_true = escenario$coef_gamma, gamma_hat = res_pca_quad$gamma)
# =======================
# AUC ROC
# =======================
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics
)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(
modelo_fpca_lin, fd_valid, modelo_fpca_lin$fpca_model$harmonics
)
y_prob_valid_pca <- predecir_probabilidades_validacion(
res_pca_quad, fd_valid, basis, modo = "PCA"
)
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(
res_pca_noquad, fd_valid, basis, modo = "PCA"
)
auc_base_fpca <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca))
auc_base_fpca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad))
auc_pca <- auc(roc(response = y_valid, predictor = y_prob_valid_pca))
auc_pca_noquad <- auc(roc(response = y_valid, predictor = y_prob_valid_pca_noquad))
# =======================
# Guardar resultados
# =======================
resultados <- rbind(resultados,
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "fpca_Upsilon0",
cuadratico = TRUE,
AUC = auc_base_fpca,
IMSE_beta = imseb_beta_fpca,
IMSE_gamma = imseb_gamma_fpca,
mse = mse_fpca
),
data.frame(
escenario = escenario_nombre,
nbasis = nbasis,
modelo = "pca_Upsilon1",
cuadratico = TRUE,
AUC = auc_pca,
IMSE_beta = imseb_beta_pca,
IMSE_gamma = imseb_gamma_pca,
mse = mse_pca
)
)
}
}
return(resultados)
}
resultados = evaluar_modelos_simulados(3000, c(10,15,30,50,80,100), t_denso = seq(-1, 1, length.out = 2001), t_ligero = seq(-1, 1, length.out = 101), seed = 123, Lcoef = c(3)
)
library(ggplot2)
ggplot(resultados, aes(x = nbasis, y = AUC, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
geom_point() +
theme_minimal() +
labs(title = "Evolución de AUC según nbasis",
x = "nbasis", y = "AUC ROC")
ggplot(resultados, aes(x = nbasis, y = IMSE_beta, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del IMSE(β)", x = "nbasis", y = "IMSE β")
resultados$IMSE_beta
ggplot(resultados, aes(x = nbasis, y = IMSE_gamma, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del IMSE(gamma)", x = "nbasis", y = "IMSE gamma")
resultados$IMSE_gamma
ggplot(resultados, aes(x = nbasis, y = mse, color = modelo, linetype = escenario)) +
geom_line(size = 1.2) +
theme_minimal() +
labs(title = "Evolución del mse", x = "nbasis", y = "MSE")
resultados$mse
