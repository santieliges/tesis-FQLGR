---
title: "simulaciónFPCA"
author: "Santiago Eliges"
date: "2025-07-31"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)

source("FQLGR.R")
```



# Librerías y Configuración Inicial

```{r}
# Instalar paquetes necesarios (si no están instalados)
if (!require("fda")) install.packages("fda")
if (!require("MASS")) install.packages("MASS")
if (!require("pROC")) install.packages("pROC")
library(pROC)
library(fda)
library(MASS)
```

# Simulación de Datos Funcionales Centrados


```{r}
# =====================================================================
# Funciones Auxiliares para Simulación y Predicción
# =====================================================================


# Funciones auxiliares ---------------------------------------------------

# Regla del trapecio 1D (para vectores x,y)
trapz1d <- function(x, y) {
  if (length(x) != length(y)) stop("x e y deben tener la misma longitud")
  idx <- 2:length(x)
  sum((x[idx] - x[idx - 1]) * (y[idx] + y[idx - 1])) / 2
}

# Integración doble por trapecio (asume matriz Z with rows correspond to s, cols to t)
trapz2d <- function(s, t, Z) {
  if (!all(dim(Z) == c(length(s), length(t)))) {
    stop("Dimensiones de Z deben ser length(s) x length(t)")
  }
  # Integramos respecto a t en cada fila -> vector de longitud length(s)
  int_t_by_row <- apply(Z, 1, function(row) trapz1d(t, row))
  # Integramos el resultado respecto a s
  trapz1d(s, int_t_by_row)
}

# IMSEB univariado -------------------------------------------------------

# beta_true / beta_hat pueden ser:
#  - vectores evaluados en la grilla t
#  - objetos 'fd' de package fda (en cuyo caso se evalúan en una grilla fina)
IMSEB_integral <- function(beta_true, beta_hat, t = NULL, grid_n = 201) {
  # Si son objetos fd, evaluarlos en grilla
  if (inherits(beta_true, "fd") || inherits(beta_hat, "fd")) {
    if (!requireNamespace("fda", quietly = TRUE)) {
      stop("Para pasar objetos 'fd' necesitas instalar paquete 'fda'")
    }
    if (is.null(t)) {
      rng <- beta_true$basis$rangeval
      t <- seq(rng[1], rng[2], length.out = grid_n)
    }
    y_true <- as.numeric(fda::eval.fd(t, beta_true))
    y_hat  <- as.numeric(fda::eval.fd(t, beta_hat))
  } else {
    # beta_true/hat deben ser vectores y se requiere t
    if (is.null(t)) stop("Si pasás vectores debes pasar el vector 't' con la grilla")
    y_true <- as.numeric(beta_true)
    y_hat  <- as.numeric(beta_hat)
    if (length(y_true) != length(t) || length(y_hat) != length(t)) {
      stop("Dimensiones de beta_true/beta_hat deben coincidir con length(t)")
    }
  }
  
  diff2 <- (y_true - y_hat)^2
  integral <- trapz1d(t, diff2)
  T_len <- max(t) - min(t)
  return(as.numeric(integral / T_len))
}

# IMBSEB bivariado -------------------------------------------------------

# Modo A: entradas discretizadas (matrices Z_true, Z_hat) sobre grilla s,t
IMBSEB_integral_grid <- function(Z_true, Z_hat, s, t) {
  if (!all(dim(Z_true) == dim(Z_hat))) stop("Z_true y Z_hat deben tener mismas dimensiones")
  if (!all(dim(Z_true) == c(length(s), length(t)))) stop("Dimensiones de Z_true deben ser length(s) x length(t)")
  
  diff2 <- (Z_true - Z_hat)^2
  integral_xy <- trapz2d(s, t, diff2)
  area <- (max(s) - min(s)) * (max(t) - min(t))
  return(as.numeric(integral_xy / area))
}

# Modo B: entradas en coeficientes de base (A_true, A_hat) y matrices Gram Psi_s, Psi_t
IMBSEB_coef_Kron <- function(A_true, A_hat, Psi_s, Psi_t, s_range = c(0,1), t_range = c(0,1)) {
  # A_true, A_hat : Ks x Kt matrices de coeficientes
  if (!all(dim(A_true) == dim(A_hat))) stop("A_true y A_hat deben tener mismas dimensiones")
  Ks <- nrow(A_true); Kt <- ncol(A_true)
  if (!all(dim(Psi_s) == c(Ks, Ks))) stop("Psi_s debe ser Ks x Ks")
  if (!all(dim(Psi_t) == c(Kt, Kt))) stop("Psi_t debe ser Kt x Kt")
  
  d <- as.vector(A_true - A_hat) # vectorización (col-major por defecto en R)
  Kmat <- kronecker(Psi_t, Psi_s) # (Ks*Kt) x (Ks*Kt)
  area <- (s_range[2] - s_range[1]) * (t_range[2] - t_range[1])
  val <- as.numeric(t(d) %*% Kmat %*% d) / area
  return(val)
}

# Función wrapper que intenta elegir modo apropiado
IMBSEB <- function(gamma_true, gamma_hat, s = NULL, t = NULL, 
                   A_mode = FALSE, Psi_s = NULL, Psi_t = NULL, s_range = NULL, t_range = NULL) {
  # Si A_mode = TRUE se usan coeficientes A_true/A_hat y Psi matrices
  if (A_mode) {
    if (is.null(Psi_s) || is.null(Psi_t)) stop("En modo coeficientes necesitás Psi_s y Psi_t")
    if (is.null(s_range) || is.null(t_range)) stop("s_range y t_range necesarios en modo coeficientes")
    return(IMBSEB_coef_Kron(gamma_true, gamma_hat, Psi_s, Psi_t, s_range, t_range))
  } else {
    # gamma_true/hat deben ser matrices en grilla y s,t provistos
    if (is.null(s) || is.null(t)) stop("Debés pasar s y t (grillas) para el modo grid")
    return(IMBSEB_integral_grid(gamma_true, gamma_hat, s, t))
  }
}

# MSEB -------------------------------------------------------
# Calcula el MSEB definido como:
# (1/(p+1))*[(alpha - alpha_hat)^2 + sum_j (beta_j - beta_hat_j)^2] +
# (1/p^2)*sum_{k,l} (gamma_{k,l} - gamma_hat_{k,l})^2
MSEB <- function(alpha_true, alpha_hat,
                 beta_true, beta_hat,
                 gamma_true, gamma_hat) {
  
  # --- Comprobaciones básicas ---
  if (!is.numeric(alpha_true) || !is.numeric(alpha_hat))
    stop("alpha_true y alpha_hat deben ser escalares numéricos")
  
  if (length(beta_true) != length(beta_hat))
    stop("beta_true y beta_hat deben tener la misma longitud")
  
  if (!all(dim(gamma_true) == dim(gamma_hat)))
    stop("gamma_true y gamma_hat deben tener las mismas dimensiones")
  
  p <- length(beta_true)  # número de covariables funcionales
  
  # --- Cálculo de componentes ---
  term_alpha <- (alpha_true - alpha_hat)^2
  
  term_beta <- sum((beta_true - beta_hat)^2)
  
  term_gamma <- sum((gamma_true - gamma_hat)^2)
  
  # --- MSEB total ---
  mse_b <- (1 / (p + 1)) * (term_alpha + term_beta) +
    (1 / (p^2))   * term_gamma
  
  return(as.numeric(mse_b))
}


predict_log_func <- function(fd_centered, psi, coef_beta, coef_gamma, alpha) {
  n <- dim(fd_centered$coefs)[2]
  probs <- numeric(n)
  for (i in 1:n) {
    lin_part <- fd_centered$coefs[,i] %*% psi %*% coef_beta
    quad_part <- fd_centered$coefs[,i] %*% psi %*% coef_gamma %*% psi %*% fd_centered$coefs[,i]
    modelo_lineal <- alpha + lin_part + quad_part
    probs[i] <- 1 / (1 + exp(-modelo_lineal))
  }
  return(probs)
}

pred_mod_log_func <- function(prob_true) {
  rbinom(length(prob_true), size = 1, prob = prob_true)
}

balance_alpha <- function(fd_centered, psi, coef_beta, coef_gamma, target = 0.5) {
  f <- function(alpha) {
    probs <- predict_log_func(fd_centered, psi, coef_beta, coef_gamma, alpha)
    mean(probs) - target
  }
  uniroot(f, c(-50, 50))$root
}

exportar_graficas_de_modelodpg <- function(modelo, varianza, conosin = "sin" ){
  plot(modelo$cost_history, type = "l", lwd = 2, col = "blue",
       xlab = "Iteraciones", ylab = "Negative Log-Likelihood",
       main = "Convergencia del descenso por gradiente")

  basis_fpca <- pca.fd(fdobj = fd_train, nharm = modelo$K, centerfns = TRUE)
  eval_fd_basis <- eval.fd(evalarg = t, fdobj= basis_fpca$harmonics)

  beta_est_pca_quad <- eval_fd_basis %*% modelo$beta
  gamma_est_pca_quad <- eval_fd_basis %*% modelo$gamma %*% t(eval_fd_basis )

    # construir nombres de archivo con paste0
    out_beta  <- file.path("plots", paste0("beta_est_",conosin,"_pen_",as.character(varianza),".png"))
    out_cont  <- file.path("plots", paste0("contour_gamma_est_",conosin,"_pen_",as.character(varianza),".png"))
    out_3d    <- file.path("plots", paste0("3dplot_gamma_est_",conosin,"_pen_",as.character(varianza),".png"))

    # exportar (ajustá los argumentos según lo que esperan tus funciones)
    exportar_plot_beta_full(
      t_grid        = t,
      beta_true     = matriz_beta,
      beta_est      = beta_est_pca_quad,
      output_filename = out_beta,
    )

    exportar_gamma_contour_full(
      t_grid         = t,
      gamma          = gamma_est_pca_quad,
      output_filename = out_cont,
    )

    exportar_plot_gamma_3d_full(
      t_grid         = t,
      gamma          = gamma_est_pca_quad,
      output_filename = out_3d,
    )

}


calcular_metricas_de_modelodpg <- function(modelo, beta_true){

  basis_fpca <- pca.fd(fdobj = fd_train, nharm = modelo$K, centerfns = TRUE)
  eval_fd_basis <- eval.fd(evalarg = t, fdobj= basis_fpca$harmonics)

  beta_est_pca_quad <- eval_fd_basis %*% modelo$beta

  gamma_est_pca_quad <- eval_fd_basis %*% modelo$gamma %*% t(eval_fd_basis )

  imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, beta_true, t)
  print(paste("IMBSEB beta: ", imseb_beta_fpca))

  imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
  print(paste("IMBSEB gamma: ", imseb_gamma_fpca))

  eig <- eigen(psi)
  psi_half <- eig$vectors %*% diag(sqrt(eig$values)) %*% t(eig$vectors)
  matriz_diseño_fpca <- t(fd_train$coefs) %*% psi_half
  pca_fpca <- prcomp(matriz_diseño_fpca)
  beta_est_fpca <- pca_fpca$rotation[,1:modelo$K] %*% modelo$beta
  gamma_est_fpca <- pca_fpca$rotation[,1:modelo$K] %*% modelo$gamma %*% t(pca_fpca$rotation[,1:modelo$K])
  mseb_quad_fpca <- MSEB(0, modelo$alpha, coef_beta, beta_est_fpca, coef_gamma, gamma_est_fpca)
  print(paste("MBSE: ", mseb_quad_fpca))

  # Probabilidades de validación
  basis_fpca <- pca.fd(fdobj = fd_train, nharm = modelo$K, centerfns = TRUE)
  y_prob_valid_pca_quad <- predecir_probabilidades_validacion_en_base_fpca(modelo, fd_valid, basis_fpca$harmonics)

  # ROC y AUC
  roc_pca_quad <- roc(response = y_valid, predictor = y_prob_valid_pca_quad)
  auc_pca_quad <- auc(roc_pca_quad)

  # PRC y AUC-PR usando PRROC
  pr_pca_quad <- pr.curve(scores.class0 = y_prob_valid_pca_quad[y_valid==1],
                          scores.class1 = y_prob_valid_pca_quad[y_valid==0],
                          curve = TRUE)

  aucpr_pca_quad <- pr_pca_quad$auc.integral

  return(list(
    MSE = mseb_quad_fpca,
    IMSEB = imseb_beta_fpca,
    IMSEG = imseb_gamma_fpca,
    auc_pca_quad = auc_pca_quad,
    aucpr_pca_quad = aucpr_pca_quad
  ))
}
```


```{r}
# =====================================================================
# Simulación de Datos Funcionales Correlacionados
# =====================================================================

library(fda)
library(MASS)

set.seed(123)
n <- 3000
nbasis <- 50
t <- seq(-1, 1, length.out = 2001)
rangeval <- c(-1, 1)

# Crear knots internos y base B-spline
internal_breaks <- seq(rangeval[1], rangeval[2], length.out = nbasis-1)
basis <- create.bspline.basis(rangeval = rangeval,  breaks = internal_breaks, nbasis = nbasis, norder = nbasis + 2 - length(internal_breaks))

# Media y covarianza de coeficientes (estructura AR(1))
mean_coef <- rnorm(nbasis, sd = seq(1, nbasis)/nbasis)
rho <- 0.8
Sigma <- outer(1:nbasis, 1:nbasis, function(i, j) rho^abs(i - j))
Sigma <- Sigma * diag(seq(nbasis, 1))

# Simulación de coeficientes correlacionados
coef <- mvrnorm(n, mu = mean_coef, Sigma = Sigma)
fd_obj <- fd(coef = t(coef), basisobj = basis)

# Gráfico de funciones simuladas
plot(fd_obj, main = "Datos Funcionales Simulados (coef. correlacionados)",
     xlab = "Tiempo", ylab = "Valor observado", col = rgb(0.2, 0.4, 0.6, 0.2))
mean_fd <- mean.fd(fd_obj)
lines(mean_fd, col = "red", lwd = 3)

#Las centro
fd_centered <- center.fd(fd_obj)


# =====================================================================
# Generación de Coeficientes Verdaderos (gamma y beta)
# =====================================================================

s <- t
beta <- 2*sin(2*pi*t) + 0.5*cos(4*pi*t)
matriz_beta <- beta / max(abs(beta))

Sigma <- 0.6
matriz_gamma <- outer(s, t, function(s, t) {
  exp(-((s - t)^2) / (2 * Sigma^2)) + 0.5*sin(pi*s)*sin(pi*t)
})
matriz_gamma <- (matriz_gamma + t(matriz_gamma)) / 2

par(mfrow = c(1, 2))
plot(t, beta, type = "l", main = expression(beta(t)), lwd = 2)
image(s, t, matriz_gamma, main = expression(gamma(s,t)), col = topo.colors(100))
contour(s, t, matriz_gamma, add = TRUE, drawlabels = FALSE)
persp(x = t, y = t, z = matriz_gamma,
      theta = 20, phi = 50, expand = 0.8,
      col = "lightblue", xlab = "s", ylab = "t", zlab = "γ(s,t)",
      main = "Superficie γ(s,t)")


# =====================================================================
# Proyección sobre la Base B-spline
# =====================================================================

fd_beta <- Data2fd(argvals = t, y = matriz_beta, basisobj = basis)
coef_beta <- fd_beta$coefs

Phi_s <- eval.basis(s, basis)
Phi_t <- eval.basis(t, basis)

A <- t(Phi_s) %*% matriz_gamma %*% Phi_t
G_s <- t(Phi_s) %*% Phi_s
G_t <- t(Phi_t) %*% Phi_t

A_est <- solve(G_s) %*% A %*% solve(G_t)
coef_gamma <- (A_est + t(A_est)) / 2

gamma_recon <- Phi_s %*% A_est %*% t(Phi_t)

par(mfrow = c(1,2))
image(s, t, matriz_gamma, main = "γ(s,t) original", col = topo.colors(100))
image(s, t, gamma_recon, main = "γ(s,t) reconstruida", col = topo.colors(100))


# =====================================================================
# División de Datos en Entrenamiento y Validación
# =====================================================================

set.seed(123)


n_total <- n
psi <- inprod(basis,basis)
idx_train <- sample(1:n_total, size = floor(0.7 * n_total))
idx_valid <- setdiff(1:n_total, idx_train)

fd_train <- fd(center.fd(fd_obj)[["coefs"]][, idx_train], basis)
fd_valid <- fd(center.fd(fd_obj)[["coefs"]][, idx_valid], basis)

alpha_true <- balance_alpha(center.fd(fd_obj), psi, coef_beta, coef_gamma)
alpha_true

prob_total <- predict_log_func(center.fd(fd_obj), psi, coef_beta, coef_gamma, alpha_true)
y_total <- pred_mod_log_func(prob_total)

y_train <- y_total[idx_train]
y_valid <- y_total[idx_valid]

hist(y_total)

```



```{r}

Lcoef = 3
harmacclLdf = vec2Lfd(Lcoef, c(-1, 1))

```

## Modelo sobre base FPCA Upsilon 0

```{r}

beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
alpha_init <- 0

modelo_fpca <- fpca_Upsilon0(fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma =gamma_init,
    alpha  = 0,
    step_gradient = 0.006,
    iterations = 15000,
    var_threshold = 0.9,
    tol = 1e-8,
    basis = basis,
    LdPenalization = harmacclLdf,
    lambda_lin = 1e-4	,
    lambda_quad = 1e-4)

basis_fpca <- modelo_fpca$fpca_model
eval_fd_basis <- eval.fd(evalarg = t, fdobj= basis_fpca$harmonics)

beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta

gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis )

imseb_beta_fpca <- IMSEB_integral(beta_est_pca_quad, matriz_beta, t)
print(paste("IMBSEB beta: ", imseb_beta_fpca))

imseb_gamma_fpca <- IMBSEB(matriz_gamma, gamma_est_pca_quad, t, t)
print(paste("IMBSEB gamma: ", imseb_gamma_fpca))


modelo_fpca_lin <- fpca_Upsilon0(fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma =gamma_init,
    alpha  = 0,
    step_gradient = 0.001,
    iterations = 15000,
    var_threshold = 0.8,
    tol = 1e-8,
    basis = basis,
    LdPenalization = harmacclLdf,
    lambda_lin = 1e-4	,
    lambda_quad = 1e-4,
    modelo_quad = FALSE
    )
```

```{r}
# t <- seq(-1, 1, length.out = 101)
# dt <- t[2] - t[1]
# basis <- create.bspline.basis(rangeval = c(-0.1, 1.1), nbasis = nbasis)
# 
# beta_init <- rnorm(nbasis, sd = 0.1)
# gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
# alpha_init <- 0
# 
# Lcoef = 3
# harmacclLdf = vec2Lfd(Lcoef, c(-1.5, 1.5))
# 
# res <- grid_search_lambda_gradient_descent_penalized_PCA(  fd_centered = fd_train,
#   y = y_train,
#   beta = beta_init,
#   gamma = gamma_init,
#   alpha = alpha_init,
#   basis = basis,
#   LdPenalization = harmacclLdf,
#   lambda_lin_values = c(0,10^seq(-5, 2, length.out = 7)),
#   lambda_quad_values = c(0,10^seq(-5, 2, length.out = 7)),#c(0,10^seq(-10, -2, length.out = 10)),
#   folds = 2,
#   iterations = 1000,
#   seq_var_threshold = c(0.7,0.8,0.9,0.99)
#   )
# 
# library(dplyr)
# 
# best_result <- res$results_df %>%
#   filter(!is.na(auc)) %>%
#   arrange(desc(auc)) %>%
#   slice(1)
# 
# print(best_result)
# 
# 
# # Convertir a log10 para visualización
# results_df <- res$results_df %>%
#   mutate(log10_lambda_lin = log10(lambda_lin),
#          log10_lambda_quad = log10(lambda_quad),
#          var_threshold = as.factor(var_threshold))  # Para facetear
# 
# ggplot(results_df, aes(x = log10_lambda_lin, y = log10_lambda_quad, fill = auc)) +
#   geom_tile(color = "white") +
#   facet_wrap(~ var_threshold, labeller = label_bquote(var[threshold] == .(var_threshold))) +
#   scale_fill_viridis_c(option = "magma", na.value = "gray90") +
#   labs(title = "AUC para cada combinación de lambda_lin y lambda_quad",
#        x = "log10(lambda_lin)",
#        y = "log10(lambda_quad)",
#        fill = "AUC") +
#   theme_minimal()


```


#Modelo PCA coef Upsilon1
```{r}


beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
alpha_init <- 0

Lcoef = 3
harmacclLdf = vec2Lfd(Lcoef, c(-1, 1))

res_pca_quad <- pca_coef_Upsilon1(
    fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma =gamma_init,
    alpha  = 0,
    step_gradient = 0.001,
    iterations = 10000,
    var_threshold = 0.8,
    tol = 1e-9,
    basis = basis,
    LdPenalization = harmacclLdf,
    lambda_lin = 1e-4	,
    lambda_quad = 0
    )

beta_est_fd <- fd(coef = res_pca_quad$beta, basisobj = basis)
imseb_beta_pca <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
print(paste("IMBSEB beta: ", imseb_beta_pca))

evalbasis <- eval.basis(t,basis)
gamma_est_matriz <-evalbasis %*% res_pca_quad$gamma %*% t(evalbasis)
imseb_gamma_pca <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(paste("IMBSEB gamma: ", imseb_gamma_pca))

res_pca_noquad <- pca_coef_Upsilon1(
    fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma =gamma_init,
    alpha  = 0,
    step_gradient = 0.05,
    iterations = 10000,
    var_threshold = 0.9,
    basis = basis,
    tol = 1e-7,
    LdPenalization = harmacclLdf,
    lambda_lin = 1e-4	,
    lambda_quad = 1e-5,
    modelo_quad = FALSE
    )
```

# hago grid search sobre el modelo plsr con penalización

```{r}
# 
# 
# beta_init <- rnorm(nbasis, sd = 0.1)
# gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
# alpha_init <- 0
# 
# 
# res_plsr_grid_search <- cv_grid_search_lambda_nt_kfold(
#   fd_data_centered = fd_train,
#   y = y_train,
#   basis = basis,
#   LdPenalization = harmacclLdf,
#   lambda_lin_values = c(0,10^seq(-5, 2, length.out = 7)),
#   lambda_quad_values = c(0,10^seq(-5, 2, length.out = 7)),#c(0,10^seq(-10, -2, length.out = 10)),
#   k_folds = 2,
#   iterations = 1000
#   )
# 
# library(dplyr)
# 
# res_plsr_grid_search
# 
# res_plsr_grid_search %>%
#   mutate(nt = factor(nt)) %>%
#   ggplot(aes(x = log10(lambda_lin), y = log10(lambda_quad), fill = auc)) +
#   geom_tile() +
#   facet_wrap(~ nt) +
#   scale_fill_viridis_c() +
#   labs(x = "log10(lambda_lin)", y = "log10(lambda_quad)", fill = "AUC ROC") +
#   theme_minimal()
# 
# res_plsr_grid_search[which.max(res_plsr_grid_search$auc), ]

```
## PLSR simple Upsilon2
```{r}

res_plsr<- PLSR_Upsilon_2(
    fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma = gamma_init,
    alpha  = 0,
    step_gradient = 0.004,
    iterations = 10000,
    tol = 1e-8,
    basis = basis,
    LdPenalization = harmacclLdf,
    nt =15,
    lambda_lin = 1e-8,
    lambda_quad = 1e-8,
    nivel_significancia = 1, 
    scale = TRUE)


beta_est_fd <- fd(coef = res_plsr$beta, basisobj = basis)
imseb_beta_plsr <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
print(paste("IMBSEB beta: ", imseb_beta_plsr))

evalbasis <- eval.basis(t,basis)
gamma_est_matriz <- evalbasis %*% res_plsr$gamma %*% t(evalbasis)

imseb_gamma_plsr <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(paste("IMBSEB gamma: ", imseb_gamma_plsr))


res_plsr_noquad<- gradient_descent_penalized_plsr(
    fd_centered=fd_train,
    y= y_train,
    beta = beta_init,
    gamma = gamma_init,
    alpha  = 0,
    step_gradient = 0.005,
    iterations = 10000,
    basis = basis,
    LdPenalization = harmacclLdf,
    nt =10,
    lambda_lin = 1e-5,
    lambda_quad = 1e-4, 
    scale = TRUE,
    modelo_quad = FALSE
    )

```

```{r}
# # Definimos los valores de significancia a evaluar
# niveles_signif_lin <- seq(0.001, 0.05, length.out = 5)
# niveles_signif_quad <- seq(0.001, 0.05, length.out = 5)
# 
# # DataFrame para almacenar los resultados
# resultados <- data.frame(
#   nivel_lin = numeric(),
#   nivel_quad = numeric(),
#   IMSE_beta = numeric(),
#   IMSE_gamma = numeric()
# )
# 
# # Bucle sobre combinaciones de niveles
# for (nl in niveles_signif_lin) {
#   for (nq in niveles_signif_quad) {
#     cat("Ejecutando combinación lin =", nl, ", quad =", nq, "\n")
# 
#     # Ejecutar modelo
#     res_plsr_2 <- FPLSR_Upsilon3(
#       fd_centered = fd_train,
#       y = y_train,
#       alpha = 0,
#       step_gradient = 0.005,
#       iterations = 10000,
#       tol = 1e-9,
#       basis = basis,
#       LdPenalization = harmacclLdf,
#       lambda_lin = 0,
#       lambda_quad = 0,
#       nt_lin = 5,
#       nt_quad = 60,
#       nivel_significancia_lin = nl,
#       nivel_significancia_quad = nq,
#       scale = TRUE
#     )
# 
#     # Calcular IMSE para beta
#     beta_est_fd <- fd(coef = res_plsr_2$beta, basisobj = basis)
#     imseb_beta <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t),
#                                  matriz_beta, t)
# 
#     # Calcular IMSE para gamma
#     evalbasis <- eval.basis(t, basis)
#     gamma_est_matriz <- evalbasis %*% res_plsr_2$gamma %*% t(evalbasis)
#     imseb_gamma <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
# 
#     # Guardar resultados
#     resultados <- rbind(resultados, data.frame(
#       nivel_lin = nl,
#       nivel_quad = nq,
#       IMSE_beta = imseb_beta,
#       IMSE_gamma = imseb_gamma
#     ))
#   }
# }
# 
# # Buscar la combinación óptima (mínima IMSE)
# mejor_beta <- resultados[which.min(resultados$IMSE_beta), ]
# mejor_gamma <- resultados[which.min(resultados$IMSE_gamma), ]
# 
# cat("\nMejor combinación para IMSE beta:\n")
# print(mejor_beta)
# 
# cat("\nMejor combinación para IMSE gamma:\n")
# print(mejor_gamma)
# 
# # Opcional: visualizar el resultado
# library(ggplot2)
# 
# ggplot(resultados, aes(x = nivel_lin, y = nivel_quad, fill = IMSE_beta)) +
#   geom_tile() +
#   scale_fill_viridis_c() +
#   labs(title = "Superficie IMSE(β)",
#        x = "Nivel significancia lineal",
#        y = "Nivel significancia cuadrática") +
#   theme_minimal()

```


## PLSR con comps cuadraticas Upsilon3
```{r}
beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
alpha_init <- 0

res_plsr_2<- FPLSR_Upsilon3(
    fd_centered=fd_train,
    y= y_train,
    alpha  = 0,
    beta = beta_init,
    gamma = gamma_init,
    step_gradient = 0.01,
    iterations = 10000,
    tol = 1e-10,
    basis = basis,
    LdPenalization = harmacclLdf,
    lambda_lin = 0,
    lambda_quad = 0,
    nt_lin = 15,
    nt_quad = 60,
    nivel_significancia_lin = 1, 
    nivel_significancia_quad = 0.05, 
    scale = TRUE)


beta_est_fd <- fd(coef = res_plsr_2$beta, basisobj = basis)
imseb_beta_plsr2 <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
print(paste("IMBSEB beta: ", imseb_beta_plsr2))

evalbasis <- eval.basis(t,basis)
gamma_est_matriz <- evalbasis %*% res_plsr_2$gamma %*% t(evalbasis)

imseb_gamma_plsr2 <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(paste("IMBSEB gamma: ", imseb_gamma_plsr2))


```



# Modelo NAIVE
```{r}


beta_init <- rnorm(nbasis, sd = 0.1)
gamma_init <- gamma_init <- matrix(rnorm(nbasis^2, sd = 0.1), nrow = nbasis)
alpha_init <- 0


res_noPCA <- Upsilon_naive(
    fd_centered=fd_train,
                                               y= y_train,     beta = beta_init,
    gamma = gamma_init,  alpha  = alpha_init, 
                                       step_gradient = 15, iterations = 10000,
                                       basis = basis, tol = 1e-9,
                                        LdPenalization = harmacclLdf,
                                       lambda_lin = 0,lambda_quad = 0)


beta_est_fd <- fd(coef = res_noPCA$beta, basisobj = basis)
imseb_beta_naive <- IMSEB_integral(eval.fd(fdobj = beta_est_fd, evalarg = t), matriz_beta, t)
print(paste("IMBSEB beta: ", imseb_beta_naive))

evalbasis <- eval.basis(t,basis)
gamma_est_matriz <- evalbasis %*% res_noPCA$gamma %*% t(evalbasis)

imseb_gamma_naive <- IMBSEB(matriz_gamma, gamma_est_matriz, t, t)
print(paste("IMBSEB gamma: ", imseb_gamma_naive))


```


# Evaluación del Modelos

Comparo las curvas roc de los 3 modelos descriptos

```{r}



# Probabilidades de validación
y_prob_valid_pca    <- predecir_probabilidades_validacion(res_pca_quad, fd_valid, basis, modo = "PCA")
y_prob_valid_pca_noquad    <- predecir_probabilidades_validacion(res_pca_noquad, fd_valid, basis, modo = "PCA")
y_prob_valid_NoPCA  <- predecir_probabilidades_validacion(res_noPCA, fd_valid, basis, modo = "NoPCA")
y_prob_valid_plsr   <- predecir_probabilidades_validacion(res_plsr, fd_valid, basis, modo = "PLSR")
y_prob_valid_plsr_noquad   <- predecir_probabilidades_validacion(res_plsr_noquad, fd_valid, basis, modo = "PLSR")
y_prob_valid_plsr_2   <- predecir_probabilidades_validacion(res_plsr_2, fd_valid, basis, modo = "PLSR")
y_prob_valid_base_fpca    <- predecir_probabilidades_validacion_en_base_fpca(modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics)
y_prob_valid_base_fpca_noquad    <- predecir_probabilidades_validacion_en_base_fpca(modelo_fpca, fd_valid, modelo_fpca$fpca_model$harmonics)

roc_pca    <- roc(response = y_valid, predictor = y_prob_valid_pca)
roc_pca_noquad    <- roc(response = y_valid, predictor = y_prob_valid_pca_noquad)
roc_noPCA  <- roc(response = y_valid, predictor = y_prob_valid_NoPCA)
roc_plsr   <- roc(response = y_valid, predictor = y_prob_valid_plsr)
roc_plsr_2   <- roc(response = y_valid, predictor = y_prob_valid_plsr_2)
roc_plsr_noquad   <- roc(response = y_valid, predictor = y_prob_valid_plsr_noquad)
roc_base_fpca  <- roc(response = y_valid, predictor = y_prob_valid_base_fpca)
roc_base_fpca_noquad    <- roc(response = y_valid, predictor = y_prob_valid_base_fpca_noquad)

auc_pca    <- auc(roc_pca)
auc_pca_noquad    <- auc(roc_pca_noquad)
auc_noPCA  <- auc(roc_noPCA)
auc_plsr   <- auc(roc_plsr)
auc_plsr_2   <- auc(roc_plsr_2)
auc_plsr_noquad   <- auc(roc_plsr_noquad)
auc_base_fpca  <- auc(roc_base_fpca)
auc_base_fpca_noquad <- auc(roc_base_fpca_noquad)

# Imprimir AUROCs
cat("AUROC con PCA cuad:        ", round(auc_pca, 4), "\n")
cat("AUROC con PCA lineal:        ", round(auc_pca_noquad, 4), "\n")
cat("AUROC sin PCA:        ", round(auc_noPCA, 4), "\n")
cat("AUROC con PLSR cuad: ", round(auc_plsr, 4), "\n")
cat("AUROC con PLSR lineal: ", round(auc_plsr_noquad, 4), "\n")
cat("AUROC con PLSR_2: ", round(auc_plsr_2, 4), "\n")
cat("AUROC base fpca: ", round(auc_base_fpca, 4), "\n")
cat("AUROC base fpca lineal: ", round(auc_base_fpca_noquad, 4), "\n")

#----- abro para la desscarga ----
# Abrir el dispositivo gráfico
png("plots/curvas_roc_comparacion_modelos.png", width = 800, height = 600, res = 120)


plot(roc_pca,    col = "darkgreen", lwd = 2, main = "Curvas ROC - Validacion", legacy.axes = TRUE)
lines(roc_pca_noquad,    col = "lightgreen", lwd = 2, lty = 3)
lines(roc_noPCA, col = "darkred",   lwd = 2, lty = 1)
lines(roc_plsr,  col = "darkblue",      lwd = 2, lty = 1)
lines(roc_plsr_noquad, col = "skyblue", lwd = 2, lty= 2)
lines(roc_plsr_2, col = "#007999", lwd = 2)
lines(roc_base_fpca, col = "purple", lwd = 2, lty = 1)
lines(roc_base_fpca_noquad, col = "violet", lwd = 2, lty = 2)

legend("bottomright",
       legend = c(
         paste0("(naive) (AUC = ", round(auc_noPCA, 4), ")"),
         paste0("(0) (AUC = ", round(auc_base_fpca, 4), ")"),
         paste0("(0) lineal (AUC = ", round(auc_base_fpca_noquad, 4), ")"),
         paste0("(1) (AUC = ", round(auc_pca, 4), ")"),
         paste0("(1) lineal (AUC = ", round(auc_pca_noquad, 4), ")"),
         paste0("(2) (AUC = ", round(auc_plsr, 4), ")"),
         paste0("(2) lineal (AUC = ", round(auc_plsr_noquad, 4), ")"),
         paste0("(3) (AUC = ", round(auc_plsr_2, 4), ")")
                ),
       col = c("darkred","purple", "violet", "darkgreen","lightgreen", "darkblue","skyblue", "#007999"),
       lwd = 2,
       lty = c(1, 1, 2, 1 ,2, 1, 2, 1),
       cex = 0.75,                    # reduce tamaño del texto
       bty = "n")

# Cerrar y guardar la imagen
dev.off()

```
```{r}
library(PRROC)

# --- Función idéntica: sigue calculando probabilidades ---
predecir_probabilidades_validacion <- function(res, fd_valid_centered, estimationBasis, modo = c("PCA", "NoPCA", "PLSR")) {
  modo <- match.arg(modo)
  psi <- inprod(estimationBasis, estimationBasis)

  A_valid <- t(fd_valid_centered$coefs)
  A_psi_valid <- A_valid %*% psi
  
  beta  <- res$beta
  gamma <- res$gamma
  alpha <- res$alpha
  
  lin_pred  <- as.vector(A_psi_valid %*% beta)
  quad_pred <- rowSums((A_psi_valid %*% gamma) * A_psi_valid)
  y_prob_valid <- 1 / (1 + exp(-(alpha + lin_pred + quad_pred)))
  
  return(y_prob_valid)
}

# --- Calcular probabilidades de validación ---
y_prob_valid_pca    <- predecir_probabilidades_validacion(res_pca_quad, fd_valid, basis, modo = "PCA")
y_prob_valid_pca_noquad <- predecir_probabilidades_validacion(res_pca_noquad, fd_valid, basis, modo = "PCA")
y_prob_valid_NoPCA  <- predecir_probabilidades_validacion(res_noPCA, fd_valid, basis, modo = "NoPCA")
y_prob_valid_plsr   <- predecir_probabilidades_validacion(res_plsr, fd_valid, basis, modo = "PLSR")
y_prob_valid_plsr_2   <- predecir_probabilidades_validacion(res_plsr_2, fd_valid, basis, modo = "PLSR")
y_prob_valid_plsr_noquad <- predecir_probabilidades_validacion(res_plsr_noquad, fd_valid, basis, modo = "PLSR")
y_prob_valid_base_fpca <- predecir_probabilidades_validacion_en_base_fpca(modelo_fpca, fd_valid, basis_fpca$harmonics)
y_prob_valid_base_fpca_noquad <- predecir_probabilidades_validacion_en_base_fpca(modelo_fpca, fd_valid, basis_fpca$harmonics)

# --- Calcular curvas PR (Precision-Recall) ---
# PRROC espera que las etiquetas positivas sean 1 y las negativas 0
get_pr <- function(y_true, y_scores) {
  pos <- y_scores[y_true == 1]
  neg <- y_scores[y_true == 0]
  pr.curve(scores.class0 = pos, scores.class1 = neg, curve = TRUE)
}

pr_pca    <- get_pr(y_valid, y_prob_valid_pca)
pr_pca_noquad <- get_pr(y_valid, y_prob_valid_pca_noquad)
pr_noPCA  <- get_pr(y_valid, y_prob_valid_NoPCA)
pr_plsr   <- get_pr(y_valid, y_prob_valid_plsr)
pr_plsr_2   <- get_pr(y_valid, y_prob_valid_plsr_2)
pr_plsr_noquad <- get_pr(y_valid, y_prob_valid_plsr_noquad)
pr_base_fpca <- get_pr(y_valid, y_prob_valid_base_fpca)
pr_base_fpca_noquad <- get_pr(y_valid, y_prob_valid_base_fpca_noquad)

# --- Extraer AUC-PR ---
auc_pr_pca    <- pr_pca$auc.integral
auc_pr_pca_noquad <- pr_pca_noquad$auc.integral
auc_pr_noPCA  <- pr_noPCA$auc.integral
auc_pr_plsr   <- pr_plsr$auc.integral
auc_pr_plsr_2   <- pr_plsr_2$auc.integral
auc_pr_plsr_noquad <- pr_plsr_noquad$auc.integral
auc_pr_base_fpca <- pr_base_fpca$auc.integral
auc_pr_base_fpca_noquad <- pr_base_fpca_noquad$auc.integral

# --- Imprimir AUC-PR ---
cat("AUC-PR con PCA cuad:        ", round(auc_pr_pca, 4), "\n")
cat("AUC-PR con PCA lineal:      ", round(auc_pr_pca_noquad, 4), "\n")
cat("AUC-PR sin PCA:             ", round(auc_pr_noPCA, 4), "\n")
cat("AUC-PR con PLSR cuad:       ", round(auc_pr_plsr, 4), "\n")
cat("AUC-PR con PLSR 2:       ", round(auc_pr_plsr_2, 4), "\n")
cat("AUC-PR con PLSR lineal:     ", round(auc_pr_plsr_noquad, 4), "\n")
cat("AUC-PR base fpca:           ", round(auc_pr_base_fpca, 4), "\n")
cat("AUC-PR base fpca lineal:    ", round(auc_pr_base_fpca_noquad, 4), "\n")

#----- abro para la desscarga ----
# Abrir el dispositivo gráfico
png("plots/curvas_pr_comparacion_modelos.png", width = 800, height = 600, res = 120)


# --- Graficar todas las curvas PR ---
plot(pr_pca$curve[,1], pr_pca$curve[,2], type = "l", col = "darkgreen", lwd = 2,
     xlab = "Recall", ylab = "Precision", main = "Curvas PR - Validación",
     ylim = c(0,1), xlim = c(0,1))
lines(pr_pca_noquad$curve[,1], pr_pca_noquad$curve[,2], col = "lightgreen", lwd = 2, lty = 3)
lines(pr_noPCA$curve[,1], pr_noPCA$curve[,2], col = "darkred", lwd = 2)
lines(pr_plsr$curve[,1], pr_plsr$curve[,2], col = "darkblue", lwd = 2)
lines(pr_plsr_noquad$curve[,1], pr_plsr_noquad$curve[,2], col = "skyblue", lwd = 2, lty = 2)
lines(pr_plsr_2$curve[,1], pr_plsr_2$curve[,2], col = "#007999", lwd = 2)
lines(pr_base_fpca$curve[,1], pr_base_fpca$curve[,2], col = "purple", lwd = 2)
lines(pr_base_fpca_noquad$curve[,1], pr_base_fpca_noquad$curve[,2], col = "violet", lwd = 2, lty = 2)

legend("bottomright",
       legend = c(
         paste0("(naive) (AUC = ", round(auc_pr_noPCA, 4), ")"),
         paste0("(0) (AUC = ", round(auc_pr_base_fpca, 4), ")"),
         paste0("(0) lineal (AUC = ", round(auc_pr_base_fpca_noquad, 4), ")"),
         paste0("(1) (AUC = ", round(auc_pr_pca, 4), ")"),
         paste0("(1) lineal (AUC = ", round(auc_pr_pca_noquad, 4), ")"),
         paste0("(2) (AUC = ", round(auc_pr_plsr, 4), ")"),
         paste0("(2) lineal (AUC = ", round(auc_pr_plsr_noquad, 4), ")"),
         paste0("(3) (AUC = ", round(auc_pr_plsr_2, 4), ")")
                ),
       col = c("darkred","purple", "violet", "darkgreen","lightgreen", "darkblue","skyblue", "#007999"),
       lwd = 2,
       lty = c(1, 1, 2, 1 ,2, 1, 2, 1),
       cex = 0.75,                    # reduce tamaño del texto
       bty = "n")
# Cerrar y guardar la imagen
dev.off()
```


```{r}
  # exportar (ajustá los argumentos según lo que esperan tus funciones)

exportar_plot_beta_full(
    t_grid         = t,
    beta_est          = matriz_beta,
    output_filename = "plots/plot_beta_verdadera.png",
  )

  exportar_gamma_contour_full(
    t_grid         = t,
    gamma          = matriz_gamma,
    output_filename = "plots/contour_gamma_verdadera.png",
  )

  exportar_plot_gamma_3d_full(
    t_grid         = t,
    gamma          = matriz_gamma,
    output_filename = "plots/plot3d_gamma_verdadera.png",
  )
```



```{r}
# Asegurate de usar los nombres correctos de tus objetos reales.
# Aquí asumo que existen:
# res_pca_quad$beta, res_plsr$beta, res_noPCA$beta, beta_est_fpca, matriz_beta
# gamma_est_pca, gamma_est_plsr, gamma_est_NOpca, gamma_est_fpca, gamma_true

evalbasis <- eval.basis(t, basis)

basis_fpca <- pca.fd(fdobj = fd_train, nharm = modelo_fpca$K, centerfns = TRUE)
eval_fd_basis <- eval.fd(evalarg = t, fdobj= basis_fpca$harmonics)

beta_est_pca_quad <- eval_fd_basis %*% modelo_fpca$beta
gamma_est_pca_quad <- eval_fd_basis %*% modelo_fpca$gamma %*% t(eval_fd_basis )

# Guardar en listas (manteniendo la estructura original: vectores/matrices)
betas_list <- list(
  PCA   = evalbasis%*%res_pca_quad$beta ,
  PLSR  = evalbasis%*%res_plsr$beta,
  Naive = evalbasis%*%res_noPCA$beta,
  FPCA  = beta_est_pca_quad,
  PLSR_2 = evalbasis%*%res_plsr_2$beta,
  Verdadera = matriz_beta
)

gammas_list <- list(
  PCA   = evalbasis%*%res_pca_quad$gamma %*% t(evalbasis),
  PLSR  = evalbasis%*%res_plsr$gamma %*% t(evalbasis),
  Naive = evalbasis%*%res_noPCA$gamma %*% t(evalbasis),      
  FPCA  = gamma_est_pca_quad,
  PLSR_2  = evalbasis%*%res_plsr_2$gamma %*% t(evalbasis),
  Verdadera = matriz_gamma      
)

nombres <- names(betas_list)   # toma los nombres de las listas (coherente)

# chequeo rápido de consistencia
if (!all(names(betas_list) == names(gammas_list))) {
  stop("Los nombres/orden de betas_list y gammas_list no coinciden.")
}

# crear carpeta plots si no existe
if (!dir.exists("plots")) dir.create("plots")

for (nm in nombres) {
  # extraer objetos por nombre
  beta_est_obj  <- betas_list[[nm]]
  gamma_est_obj <- gammas_list[[nm]]

  # construir nombres de archivo con paste0
  out_beta  <- file.path("plots", paste0("beta_est_", nm, "_gscv.png"))
  out_cont  <- file.path("plots", paste0("contour_gamma_est_", nm, "_gscv.png"))
  out_3d    <- file.path("plots", paste0("3dplot_gamma_est_", nm, "_gscv.png"))

  # exportar (ajustá los argumentos según lo que esperan tus funciones)
  exportar_plot_beta_full(
    t_grid        = t,
    beta_true     = matriz_beta,
    beta_est      = beta_est_obj,
    output_filename = out_beta,
    title_suffix  = paste0(nm)
  )

  exportar_gamma_contour_full(
    t_grid         = t,
    gamma          = gamma_est_obj,
    output_filename = out_cont,
    title_suffix   = paste0(nm)
  )

  exportar_plot_gamma_3d_full(
    t_grid         = t,
    gamma          = gamma_est_obj,
    output_filename = out_3d,
    title_suffix   = paste0(nm)
  )
}



```
Vemos que PLSR parece ser bastante peor en este caso, pero hay que tener en cuenta que consigue una representación no tan mala con tan solo 3 componentes! (se ve mejor en el grafico del final)

#CAMBIO PENALIZACIÓN POR PARAMETROS LINEALES

```{r}
library(pROC)
library(ggplot2)
library(reshape2)

#------------------------------------------------------------
# 1. Función para predecir probabilidades
#------------------------------------------------------------
predecir_probabilidades_validacion_en_base_fpca <- function(res, fd_valid_centered, estimationBasis) {
  change_basis <- inprod(fd_valid_centered$basis, estimationBasis)
  A_valid <- t(fd_valid_centered$coefs)
  A_psi_valid <- A_valid %*% change_basis

  beta  <- as.vector(res$beta)
  gamma <- res$gamma
  alpha <- res$alpha

  lin_pred  <- as.vector(A_psi_valid %*% beta)
  quad_pred <- rowSums((A_psi_valid %*% gamma) * A_psi_valid)
  y_prob_valid <- 1 / (1 + exp(-(alpha + lin_pred + quad_pred)))
  return(y_prob_valid)
}

#------------------------------------------------------------
# 2. Parámetros del experimento
#------------------------------------------------------------
varianza_fija <- 0.9  # o 0.9, según el caso

lambdas_lin <- c(0, 1e-6, 1e-4, 1e-2, 1e2, 1e4)

base_params <- list(
  ldfobj = 3,
  modelo_quad = TRUE,   # mantenemos modelo cuadrático
  step_gradient = 0.001,
  lambda_quad = 0,      # penalización cuadrática fija en cero
  iterations = 10000,
  tol = 1e-9
)

#------------------------------------------------------------
# 3. Inicialización de métricas y datos ROC
#------------------------------------------------------------
mse_vals <- imseb_vals <- imseg_vals <- auc_roc_vals <- auc_pr_vals <- numeric(length(lambdas_lin))
roc_data <- list()

#------------------------------------------------------------
# 4. Bucle sobre las penalizaciones lineales
#------------------------------------------------------------
for (i in seq_along(lambdas_lin)) {
  lambda_l <- lambdas_lin[i]
  cat("\n=== Entrenando modelo con λ_lin =", lambda_l, "===\n")
  
  # Definir penalización
  roughtnessPenalty <- modifyList(base_params, list(lambda_lin = lambda_l))
  
  modelo_pen <- fpca_Upsilon0(fd_centered=fd_train,
    y= y_train,
    beta = modelo_fpca$beta,
    gamma = modelo_fpca$gamma,
    alpha  = 0,
    step_gradient = 0.01,
    iterations = 1000,
    var_threshold = varianza_fija,
    tol = 1e-9,
    basis = basis,
    LdPenalization = harmacclLdf,
    lambda_lin = lambda_l	,
    lambda_quad = 0)
  
  
  # Exportar β y γ estimados
  exportar_graficas_de_modelodpg(modelo_pen, paste0(varianza_fija, "_lambda_lin_", lambda_l), "pen")
  
  # Calcular métricas
  metricas <- calcular_metricas_de_modelodpg(modelo_pen, matriz_beta)
  mse_vals[i]   <- metricas$MSE
  imseb_vals[i] <- metricas$IMSEB
  imseg_vals[i] <- metricas$IMSEG
  auc_roc_vals[i]   <- metricas$auc_pca_quad
  auc_pr_vals[i] <- metricas$aucpr_pca_quad
  # Calcular curva ROC en base de validación
  basis_fpca <- pca.fd(fdobj = fd_train, nharm = modelo_pen$K, centerfns = TRUE)
  y_prob_valid_pca_quad <- predecir_probabilidades_validacion_en_base_fpca(modelo_pen, fd_valid,  modelo_pen$fpca_model$harmonics)
  roc_obj <- roc(response = y_valid, predictor = y_prob_valid_pca_quad)
  
  roc_data[[i]] <- data.frame(
    fpr = 1 - roc_obj$specificities,
    tpr = roc_obj$sensitivities,
    lambda = paste0("λ=", format(lambda_l, scientific = TRUE))
  )
}

#------------------------------------------------------------
# 5. Consolidar y graficar ROC
#------------------------------------------------------------
roc_df <- do.call(rbind, roc_data)

ggplot(roc_df, aes(x = fpr, y = tpr, color = lambda)) +
  geom_line(linewidth = 1.1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  coord_equal() +
  theme_minimal(base_size = 13) +
  labs(
    title = bquote("Curvas ROC para distintos valores de" ~ lambda[lin] ~ 
                   "(varianza explicada =" ~ .(varianza_fija) ~ ")"),
    x = "1 - Especificidad (FPR)",
    y = "Sensibilidad (TPR)",
    color = expression(lambda[lin])
  )

ggsave(
  filename = file.path("plots", paste0("curvas_ROC_lambda_lin_var_", varianza_fija, ".png")),
  width = 7, height = 6, dpi = 300
)

#------------------------------------------------------------
# 6. Tabla resumen de métricas
#------------------------------------------------------------
metricas_df_penalizacion_lin <- data.frame(
  lambda_lin = lambdas_lin,
  MSE = mse_vals,
  IMSE_beta = imseb_vals,
  IMSE_gamma = imseg_vals,
  AUCROC = auc_roc_vals,
  AUCPR = auc_pr_vals
)
print(metricas_df_penalizacion_lin)

```
